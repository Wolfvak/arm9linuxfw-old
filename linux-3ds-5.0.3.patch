diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/Kconfig linux-3ds/arch/arm/Kconfig
--- linux-5.0.3/arch/arm/Kconfig	2019-03-19 09:10:58.000000000 -0300
+++ linux-3ds/arch/arm/Kconfig	2019-05-04 18:53:35.893807600 -0300
@@ -384,6 +384,23 @@
 	help
 	  This enables support for systems based on the Hilscher NetX Soc
 
+config ARCH_NINTENDO3DS
+	bool "Nintendo 3DS"
+	select ARM_GIC
+	select ARM_AMBA
+	select CPU_V6K
+	select HAVE_SMP
+	select HAVE_ARM_SCU
+	select HAVE_ARM_TWD
+	select GENERIC_IRQ_CHIP
+	select GENERIC_CLOCKEVENTS
+	select CLKDEV_LOOKUP
+	select COMMON_CLK
+	select GENERIC_CLOCKEVENTS
+	select USE_OF
+	help
+	  Support for the Nintendo 3DS game console.
+
 config ARCH_IOP13XX
 	bool "IOP13xx-based"
 	depends on MMU
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/Makefile linux-3ds/arch/arm/Makefile
--- linux-5.0.3/arch/arm/Makefile	2019-03-19 09:10:58.000000000 -0300
+++ linux-3ds/arch/arm/Makefile	2019-05-04 18:53:35.895784600 -0300
@@ -192,6 +192,7 @@
 machine-$(CONFIG_ARCH_MEDIATEK)		+= mediatek
 machine-$(CONFIG_ARCH_MXS)		+= mxs
 machine-$(CONFIG_ARCH_NETX)		+= netx
+machine-$(CONFIG_ARCH_NINTENDO3DS)	+= nintendo3ds
 machine-$(CONFIG_ARCH_NOMADIK)		+= nomadik
 machine-$(CONFIG_ARCH_NPCM)		+= npcm
 machine-$(CONFIG_ARCH_NSPIRE)		+= nspire
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/boot/dts/nintendo3ds_ctr.dts linux-3ds/arch/arm/boot/dts/nintendo3ds_ctr.dts
--- linux-5.0.3/arch/arm/boot/dts/nintendo3ds_ctr.dts	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/boot/dts/nintendo3ds_ctr.dts	2019-05-11 23:01:14.824711700 -0300
@@ -0,0 +1,244 @@
+/dts-v1/;
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	model = "Nintendo 3DS (CTR)";
+	compatible = "nintendo3ds,ctr";
+	#address-cells = <1>;
+	#size-cells = <1>;
+	interrupt-parent = <&gic>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		enable-method = "nintendo3ds,smp";
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,arm11mpcore";
+			reg = <0>;
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,arm11mpcore";
+			reg = <1>;
+		};
+	};
+
+	chosen {
+		/* No FB: bootargs = "earlyprintk keep_bootcon fbcon=rotate:1 init=/init"; */
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		bootargs = "nr_cpus=2 keep_bootcon fbcon=rotate:1 root=/dev/ram0 init=init console=tty0";
+
+		display: framebuffer@18000000 {
+			compatible = "simple-framebuffer";
+			reg = <0x18000000 (400*240*3)>;
+			width = <240>;
+			height = <400>;
+			stride = <(240*3)>;
+			format = "r8g8b8";
+		};
+
+		fcram: memory@20000000 {
+			device_type = "memory";
+			reg = <0x20000000 0x08000000>;
+		};
+	};
+
+	soc {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		compatible = "simple-bus";
+
+		interrupt-parent = <&gic>;
+
+		keys: input@10146000 {
+			compatible = "nintendo3ds,nintendo3ds-input";
+			reg = <0x10146000 0x1000>;
+		};
+
+		backlight: backlight@10202000 {
+			compatible = "nintendo3ds,nintendo3ds-backlight";
+			reg = <0x10202000 0x4000>;
+		};
+
+		pxi: pxi@10163000 {
+			compatible = "nintendo3ds,nintendo3ds-pxi";
+			interrupts =
+				<GIC_SPI 0x30 IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x33 IRQ_TYPE_EDGE_RISING>;
+			reg = <0x10163000 0x1000>;
+
+			mmc: mmc {
+				compatible = "nintendo3ds,nintendo3ds-mmc";
+			};
+
+			rng: rng {
+				compatible = "nintendo3ds,nintendo3ds-rng";
+			};
+		};
+
+		i2c1: i2c@10161000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-i2c";
+			reg = <0x10161000 0x1000>;
+		};
+
+		i2c2: i2c@10144000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-i2c";
+			reg = <0x10144000 0x1000>;
+
+			mcu: mcu@4a {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				compatible = "nintendo3ds,nintendo3ds-mcu";
+				reg = <0x4A>;
+
+				mcuhid {
+					interrupt-parent = <&gic>;
+
+					compatible = "nintendo3ds,nintendo3ds-mcuhid";
+					interrupts = <GIC_SPI 0x51 IRQ_TYPE_EDGE_RISING>;
+				};
+
+				charger {
+					compatible = "nintendo3ds,nintendo3ds-charger";
+				};
+
+				reset {
+					compatible = "nintendo3ds,nintendo3ds-reset";
+				};
+
+				leds {
+					compatible = "nintendo3ds,nintendo3ds-leds";
+				};
+
+				rtc {
+					compatible = "nintendo3ds,nintendo3ds-rtc";
+				};
+
+			};
+		};
+
+		i2c3: i2c@10148000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-i2c";
+			reg = <0x10148000 0x1000>;
+		};
+
+		spi0: spi@10160000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-spi";
+			reg = <0x10160000 0x1000>;
+
+			flash: nvram@1 {
+				compatible = "jedec,spi-nor";
+				reg = <1>;
+
+				spi-max-frequency = <256000>;
+			};
+		};
+
+		spi1: spi@10142000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-spi";
+			reg = <0x10142000 0x1000>;
+
+			ts: codec@3 {
+				compatible = "nintendo3ds,nintendo3ds-codec";
+				spi-max-frequency = <4000000>;
+				reg = <3>;
+
+				touchscreen-size-x = <4096>;
+				touchscreen-size-y = <4096>;
+				touchscreen-inverted-y;
+				touchscreen-swapped-x-y;
+			};
+		};
+
+		spi2: spi@10143000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-spi";
+			reg = <0x10143000 0x1000>;
+		};
+
+		refclk: refclk134mkhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <134000000>;
+			clock-output-names = "nintendo3ds:refclk144khz";
+		};
+
+		timer: twd-timer@17E00600 {
+			compatible = "arm,arm11mp-twd-timer";
+			reg = <0x17E00600 0x20>;
+			interrupts = <GIC_PPI 13 (GIC_CPU_MASK_RAW(0xF) | IRQ_TYPE_EDGE_RISING)>;
+			clocks = <&refclk>;
+		};
+
+		watchdog: twd-watchdog@17E00620 {
+			compatible = "arm,arm11mp-twd-wdt";
+			reg = <0x17E00620 0x20>;
+			interrupts = <GIC_PPI 14 (GIC_CPU_MASK_RAW(0xF) | IRQ_TYPE_EDGE_RISING)>;
+		};
+
+		gic: interrupt-controller@17E01000 {
+			compatible = "arm,arm11mp-gic";
+			#interrupt-cells = <3>;
+			#address-cells = <1>;
+			interrupt-controller;
+			reg = <0x17E01000 0x1000>,
+			      <0x17E00100 0x100>;
+		};
+
+		scu: scu@17E00000 {
+			compatible = "arm,arm11mp-scu";
+			reg = <0x17E00000 0x100>;
+		};
+	};
+
+	amba {
+		compatible = "arm,amba-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		dma@10200000 {
+			compatible = "arm,pl330", "arm,primecell";
+			reg = <0x10200000 0x1000>;
+
+			clocks = <&refclk>;
+			clock-names = "apb_pclk";
+
+			interrupts =
+				<GIC_SPI 0x39 IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x3A IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x3B IRQ_TYPE_EDGE_RISING>;
+
+			#dma-cells = <1>;
+			#dma-channels = <8>;
+			#dma-requests = <32>;
+		};
+	};
+
+};
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/configs/nintendo3ds_defconfig linux-3ds/arch/arm/configs/nintendo3ds_defconfig
--- linux-5.0.3/arch/arm/configs/nintendo3ds_defconfig	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/configs/nintendo3ds_defconfig	2019-05-13 09:33:39.163124200 -0300
@@ -0,0 +1,2411 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 5.0.3 Kernel Configuration
+#
+
+#
+# Compiler: arm-linux-gnueabi-gcc (Ubuntu/Linaro 7.4.0-1ubuntu1~18.04) 7.4.0
+#
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=70400
+CONFIG_CLANG_VERSION=0
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_BUILD_SALT=""
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="nintendo3ds"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_USELIB=y
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_IRQ_FORCED_THREADING=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_HZ_PERIODIC=y
+# CONFIG_NO_HZ_IDLE is not set
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+# CONFIG_TASKSTATS is not set
+# CONFIG_PSI is not set
+CONFIG_CPU_ISOLATION=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_CGROUPS=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+CONFIG_MEMCG_SWAP=y
+# CONFIG_MEMCG_SWAP_ENABLED is not set
+CONFIG_MEMCG_KMEM=y
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+CONFIG_CGROUP_WRITEBACK=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+# CONFIG_RT_GROUP_SCHED is not set
+# CONFIG_CGROUP_PIDS is not set
+# CONFIG_CGROUP_RDMA is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="/home/wolfvak/rootfs"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION=".gz"
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_FHANDLE=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+# CONFIG_BPF_SYSCALL is not set
+# CONFIG_USERFAULTFD is not set
+CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE=y
+CONFIG_RSEQ=y
+# CONFIG_DEBUG_RSEQ is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLUB_MEMCG_SYSFS_ON is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+CONFIG_SLUB_CPU_PARTIAL=y
+CONFIG_SYSTEM_DATA_VERIFICATION=y
+# CONFIG_PROFILING is not set
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_PHYS_OFFSET=0x20000000
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+CONFIG_ARCH_NINTENDO3DS=y
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V6K=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_V6=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_KUSER_HELPERS=y
+CONFIG_DMA_CACHE_RWFO=y
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_DEBUG_ALIGN_RODATA=y
+# CONFIG_ARM_ERRATA_411920 is not set
+
+#
+# Bus support
+#
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+# CONFIG_SMP_ON_UP is not set
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_HAVE_ARM_TWD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_HZ_FIXED=0
+# CONFIG_HZ_100 is not set
+# CONFIG_HZ_200 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+# CONFIG_ATAGS is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_ATTR_SET=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+# CONFIG_CPU_FREQ_GOV_SCHEDUTIL is not set
+
+#
+# CPU frequency scaling drivers
+#
+# CONFIG_CPUFREQ_DT is not set
+# CONFIG_QORIQ_CPUFREQ is not set
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_DT_IDLE_STATES=y
+
+#
+# ARM CPU Idle Drivers
+#
+CONFIG_ARM_CPUIDLE=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+# CONFIG_HIBERNATION is not set
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_AUTOSLEEP=y
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_CPU_PM=y
+# CONFIG_ENERGY_MODEL is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FW_CFG_SYSFS is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+# CONFIG_ARM_CRYPTO is not set
+# CONFIG_VIRTUALIZATION is not set
+
+#
+# General architecture-dependent options
+#
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_FORTIFY_SOURCE=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_RSEQ=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_STACKPROTECTOR=y
+CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
+CONFIG_STACKPROTECTOR=y
+# CONFIG_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS=8
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+CONFIG_ARCH_HAS_PHYS_TO_DMA=y
+CONFIG_REFCOUNT_FULL=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_PLUGIN_HOSTCC=""
+CONFIG_HAVE_GCC_PLUGINS=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_MODULE_SIG=y
+# CONFIG_MODULE_SIG_FORCE is not set
+CONFIG_MODULE_SIG_ALL=y
+# CONFIG_MODULE_SIG_SHA1 is not set
+# CONFIG_MODULE_SIG_SHA224 is not set
+# CONFIG_MODULE_SIG_SHA256 is not set
+# CONFIG_MODULE_SIG_SHA384 is not set
+CONFIG_MODULE_SIG_SHA512=y
+CONFIG_MODULE_SIG_HASH="sha512"
+# CONFIG_MODULE_COMPRESS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+# CONFIG_BLK_DEV_ZONED is not set
+CONFIG_BLK_DEV_THROTTLING=y
+# CONFIG_BLK_DEV_THROTTLING_LOW is not set
+CONFIG_BLK_CMDLINE_PARSER=y
+# CONFIG_BLK_WBT is not set
+# CONFIG_BLK_CGROUP_IOLATENCY is not set
+CONFIG_BLK_DEBUG_FS=y
+# CONFIG_BLK_SED_OPAL is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+CONFIG_LDM_PARTITION=y
+# CONFIG_LDM_DEBUG is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+CONFIG_BLK_PM=y
+
+#
+# IO Schedulers
+#
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+# CONFIG_IOSCHED_BFQ is not set
+CONFIG_ASN1=y
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_FDPIC is not set
+CONFIG_ELFCORE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_FLAT is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_COREDUMP=y
+
+#
+# Memory Management options
+#
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_BENCHMARK is not set
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+# CONFIG_NET_KEY is not set
+# CONFIG_INET is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_DNS_RESOLVER is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_BT is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+# CONFIG_NET_DEVLINK is not set
+CONFIG_MAY_USE_DEVLINK=y
+# CONFIG_FAILOVER is not set
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCCARD is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+
+#
+# Bus devices
+#
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_SIMPLE_PM_BUS is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_GNSS is not set
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_OF_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# Partition parsers
+#
+# CONFIG_MTD_REDBOOT_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+# CONFIG_MTD_BLOCK is not set
+# CONFIG_MTD_BLOCK_RO is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_M25P80=y
+# CONFIG_MTD_MCHP23K256 is not set
+CONFIG_MTD_SST25L=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# CONFIG_MTD_ONENAND is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_SPI_NAND is not set
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_LPDDR2_NVM is not set
+CONFIG_MTD_SPI_NOR=y
+# CONFIG_MTD_MT81xx_NOR is not set
+CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=y
+# CONFIG_SPI_CADENCE_QUADSPI is not set
+# CONFIG_MTD_UBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+CONFIG_BLK_DEV_NULL_BLK=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+
+#
+# DRBD disabled because PROC_FS or INET not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# NVME Support
+#
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TARGET is not set
+
+#
+# Misc devices
+#
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_SRAM is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+# CONFIG_EEPROM_EE1004 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Intel MIC & related support
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# CONFIG_ECHO is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_NETDEVICES is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_LEDS=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_SPARSEKMAP=y
+CONFIG_INPUT_MATRIXKMAP=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_PROPERTIES=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_AR1021_I2C is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_BU21029 is not set
+# CONFIG_TOUCHSCREEN_CHIPONE_ICN8318 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_CYTTSP4_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_EGALAX_SERIAL is not set
+# CONFIG_TOUCHSCREEN_EXC3000 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GOODIX is not set
+# CONFIG_TOUCHSCREEN_HIDEEP is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_S6SY761 is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_EKTF2127 is not set
+# CONFIG_TOUCHSCREEN_ELAN is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MELFAS_MIP4 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_IMX6UL_TSC is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_WDT87XX_I2C is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2004 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_RM_TS is not set
+# CONFIG_TOUCHSCREEN_SILEAD is not set
+# CONFIG_TOUCHSCREEN_SIS_I2C is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_STMFTS is not set
+# CONFIG_TOUCHSCREEN_SURFACE3_SPI is not set
+# CONFIG_TOUCHSCREEN_SX8654 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_ZET6223 is not set
+# CONFIG_TOUCHSCREEN_ZFORCE is not set
+# CONFIG_TOUCHSCREEN_ROHM_BU21023 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATMEL_CAPTOUCH is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+# CONFIG_INPUT_KXTJ9 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_DRV260X_HAPTICS is not set
+# CONFIG_INPUT_DRV2665_HAPTICS is not set
+# CONFIG_INPUT_DRV2667_HAPTICS is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=0
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_N_HDLC is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_UARTLITE is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# CONFIG_SERIAL_DEV_BUS is not set
+CONFIG_TTY_PRINTK=y
+CONFIG_TTY_PRINTK_LEVEL=6
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+CONFIG_RAW_DRIVER=y
+CONFIG_MAX_RAW_DEVS=256
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_GPMUX is not set
+# CONFIG_I2C_MUX_LTC4306 is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+# CONFIG_I2C_DEMUX_PINCTRL is not set
+# CONFIG_I2C_MUX_MLXCPLD is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I3C is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_MEM=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_DESIGNWARE is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_MXIC is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_LOOPBACK_TEST is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_SLAVE is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+# CONFIG_PPS is not set
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_MCP23S08 is not set
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_SX150X is not set
+# CONFIG_PINCTRL_OCELOT is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_CADENCE is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+CONFIG_GPIO_GENERIC_PLATFORM=y
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+# CONFIG_GPIO_PL061 is not set
+# CONFIG_GPIO_SAMA5D2_PIOBU is not set
+# CONFIG_GPIO_SYSCON is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_TPIC2810 is not set
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_BRCMKONA is not set
+# CONFIG_POWER_RESET_BRCMSTB is not set
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_GPIO_RESTART is not set
+# CONFIG_POWER_RESET_LTC2952 is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_RESET_VERSATILE is not set
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_POWER_RESET_SYSCON_POWEROFF=y
+# CONFIG_SYSCON_REBOOT_MODE is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_CHARGER_ADP5061 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_CHARGER_SBS is not set
+# CONFIG_MANAGER_SBS is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_LTC3651 is not set
+# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_ACT8945A is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_RC_CORE is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_DRM_DP_CEC is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+
+#
+# AMD Library routines
+#
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+CONFIG_FB_SIMPLE=y
+# CONFIG_FB_SSD1307 is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI922X is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_AMS369FG06 is not set
+# CONFIG_LCD_LMS501KF03 is not set
+# CONFIG_LCD_HX8357 is not set
+# CONFIG_LCD_OTM3225A is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+# CONFIG_BACKLIGHT_PM8941_WLED is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_GPIO is not set
+# CONFIG_BACKLIGHT_LV5207LP is not set
+# CONFIG_BACKLIGHT_BD6107 is not set
+# CONFIG_BACKLIGHT_ARCXCNN is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER is not set
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+# CONFIG_HID is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_CLASS_FLASH is not set
+# CONFIG_LEDS_BRIGHTNESS_HW_CHANGED is not set
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_AN30259A is not set
+# CONFIG_LEDS_BCM6328 is not set
+# CONFIG_LEDS_BCM6358 is not set
+# CONFIG_LEDS_CR0014114 is not set
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_LM3692X is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP3952 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_LP8501 is not set
+# CONFIG_LEDS_LP8860 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA963X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_TLC591XX is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_IS31FL319X is not set
+# CONFIG_LEDS_IS31FL32XX is not set
+
+#
+# LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)
+#
+# CONFIG_LEDS_BLINKM is not set
+# CONFIG_LEDS_SYSCON is not set
+# CONFIG_LEDS_MLXREG is not set
+# CONFIG_LEDS_USER is not set
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+CONFIG_RTC_NVMEM=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12026 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF85363 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1302 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6916 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RX6110 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+CONFIG_RTC_I2C_AND_SPI=y
+
+#
+# SPI and I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_OF=y
+# CONFIG_ALTERA_MSGDMA is not set
+# CONFIG_AMBA_PL08X is not set
+# CONFIG_DW_AXI_DMAC is not set
+# CONFIG_FSL_EDMA is not set
+# CONFIG_INTEL_IDMA64 is not set
+# CONFIG_NBPFAXI_DMA is not set
+CONFIG_PL330_DMA=y
+# CONFIG_QCOM_HIDMA_MGMT is not set
+# CONFIG_QCOM_HIDMA is not set
+# CONFIG_DW_DMAC is not set
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=y
+CONFIG_UIO_PDRV_GENIRQ=y
+CONFIG_UIO_DMEM_GENIRQ=y
+# CONFIG_UIO_PRUSS is not set
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_VIRTIO_MENU is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+CONFIG_NINTENDO3DS_PLATFORM_DEVICES=y
+CONFIG_NINTENDO3DS_HID=y
+CONFIG_NINTENDO3DS_SPI=y
+CONFIG_NINTENDO3DS_CODEC=y
+CONFIG_NINTENDO3DS_PXI=y
+CONFIG_NINTENDO3DS_MMC=y
+CONFIG_NINTENDO3DS_RNG=y
+CONFIG_NINTENDO3DS_I2C=y
+CONFIG_NINTENDO3DS_MCU=y
+CONFIG_NINTENDO3DS_RTC=y
+CONFIG_NINTENDO3DS_LEDS=y
+CONFIG_NINTENDO3DS_RESET=y
+CONFIG_NINTENDO3DS_MCUHID=y
+CONFIG_NINTENDO3DS_CHARGER=y
+CONFIG_NINTENDO3DS_BACKLIGHT=y
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_MELLANOX_PLATFORM is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_HSDK is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+# CONFIG_HWSPINLOCK is not set
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+# CONFIG_ARM_TIMER_SP804 is not set
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_RPMSG_VIRTIO is not set
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+
+#
+# i.MX SoC drivers
+#
+
+#
+# Qualcomm SoC drivers
+#
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# CONFIG_XILINX_VCU is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+# CONFIG_IPACK_BUS is not set
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_RESET_TI_SYSCON is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_CADENCE_DP is not set
+# CONFIG_PHY_CADENCE_SIERRA is not set
+# CONFIG_PHY_FSL_IMX8MQ_USB is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_OCELOT_SERDES is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+# CONFIG_ARM_CCN is not set
+CONFIG_ARM_PMU=y
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_FS_IOMAP=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT2=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_F2FS_FS=y
+CONFIG_F2FS_STAT_FS=y
+CONFIG_F2FS_FS_XATTR=y
+CONFIG_F2FS_FS_POSIX_ACL=y
+# CONFIG_F2FS_FS_SECURITY is not set
+# CONFIG_F2FS_CHECK_FS is not set
+CONFIG_F2FS_FS_ENCRYPTION=y
+# CONFIG_F2FS_FAULT_INJECTION is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_MANDATORY_FILE_LOCKING=y
+CONFIG_FS_ENCRYPTION=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+# CONFIG_QUOTA is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_AUTOFS_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+# CONFIG_FSCACHE_HISTOGRAM is not set
+# CONFIG_FSCACHE_DEBUG is not set
+# CONFIG_FSCACHE_OBJECT_LIST is not set
+CONFIG_CACHEFILES=y
+# CONFIG_CACHEFILES_DEBUG is not set
+# CONFIG_CACHEFILES_HISTOGRAM is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_MEMFD_CREATE=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=y
+CONFIG_NLS_CODEPAGE_775=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_CODEPAGE_852=y
+CONFIG_NLS_CODEPAGE_855=y
+CONFIG_NLS_CODEPAGE_857=y
+CONFIG_NLS_CODEPAGE_860=y
+CONFIG_NLS_CODEPAGE_861=y
+CONFIG_NLS_CODEPAGE_862=y
+CONFIG_NLS_CODEPAGE_863=y
+CONFIG_NLS_CODEPAGE_864=y
+CONFIG_NLS_CODEPAGE_865=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_869=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_CODEPAGE_874=y
+CONFIG_NLS_ISO8859_8=y
+CONFIG_NLS_CODEPAGE_1250=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+CONFIG_NLS_ISO8859_3=y
+CONFIG_NLS_ISO8859_4=y
+CONFIG_NLS_ISO8859_5=y
+CONFIG_NLS_ISO8859_6=y
+CONFIG_NLS_ISO8859_7=y
+CONFIG_NLS_ISO8859_9=y
+CONFIG_NLS_ISO8859_13=y
+CONFIG_NLS_ISO8859_14=y
+CONFIG_NLS_ISO8859_15=y
+CONFIG_NLS_KOI8_R=y
+CONFIG_NLS_KOI8_U=y
+CONFIG_NLS_MAC_ROMAN=y
+CONFIG_NLS_MAC_CELTIC=y
+CONFIG_NLS_MAC_CENTEURO=y
+CONFIG_NLS_MAC_CROATIAN=y
+CONFIG_NLS_MAC_CYRILLIC=y
+CONFIG_NLS_MAC_GAELIC=y
+CONFIG_NLS_MAC_GREEK=y
+CONFIG_NLS_MAC_ICELAND=y
+CONFIG_NLS_MAC_INUIT=y
+CONFIG_NLS_MAC_ROMANIAN=y
+CONFIG_NLS_MAC_TURKISH=y
+CONFIG_NLS_UTF8=y
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_PERSISTENT_KEYRINGS=y
+CONFIG_BIG_KEYS=y
+CONFIG_ENCRYPTED_KEYS=y
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+CONFIG_SECURITYFS=y
+# CONFIG_SECURITY_NETWORK is not set
+CONFIG_SECURITY_PATH=y
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_FORTIFY_SOURCE is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_LOADPIN is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_INTEGRITY is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_RSA=y
+# CONFIG_CRYPTO_DH is not set
+# CONFIG_CRYPTO_ECDH is not set
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CRYPTO_CRYPTD=y
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_CHACHA20POLY1305=y
+# CONFIG_CRYPTO_AEGIS128 is not set
+# CONFIG_CRYPTO_AEGIS128L is not set
+# CONFIG_CRYPTO_AEGIS256 is not set
+# CONFIG_CRYPTO_MORUS640 is not set
+# CONFIG_CRYPTO_MORUS1280 is not set
+CONFIG_CRYPTO_SEQIV=y
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CFB is not set
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_LRW=y
+# CONFIG_CRYPTO_OFB is not set
+CONFIG_CRYPTO_PCBC=y
+CONFIG_CRYPTO_XTS=y
+# CONFIG_CRYPTO_KEYWRAP is not set
+# CONFIG_CRYPTO_ADIANTUM is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_XCBC=y
+CONFIG_CRYPTO_VMAC=y
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_CRC32=y
+CONFIG_CRYPTO_CRCT10DIF=y
+CONFIG_CRYPTO_GHASH=y
+CONFIG_CRYPTO_POLY1305=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_RMD128=y
+CONFIG_CRYPTO_RMD160=y
+CONFIG_CRYPTO_RMD256=y
+CONFIG_CRYPTO_RMD320=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_STREEBOG is not set
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_WP512=y
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+CONFIG_CRYPTO_ANUBIS=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_BLOWFISH_COMMON=y
+CONFIG_CRYPTO_CAMELLIA=y
+CONFIG_CRYPTO_CAST_COMMON=y
+CONFIG_CRYPTO_CAST5=y
+CONFIG_CRYPTO_CAST6=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_FCRYPT=y
+CONFIG_CRYPTO_KHAZAD=y
+CONFIG_CRYPTO_SALSA20=y
+CONFIG_CRYPTO_CHACHA20=y
+CONFIG_CRYPTO_SEED=y
+CONFIG_CRYPTO_SERPENT=y
+# CONFIG_CRYPTO_SM4 is not set
+CONFIG_CRYPTO_TEA=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+CONFIG_CRYPTO_842=y
+CONFIG_CRYPTO_LZ4=y
+CONFIG_CRYPTO_LZ4HC=y
+# CONFIG_CRYPTO_ZSTD is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+# CONFIG_CRYPTO_DRBG_CTR is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HASH_INFO=y
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_CCREE is not set
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
+CONFIG_X509_CERTIFICATE_PARSER=y
+# CONFIG_PKCS8_PRIVATE_KEY_PARSER is not set
+CONFIG_PKCS7_MESSAGE_PARSER=y
+# CONFIG_PKCS7_TEST_KEY is not set
+# CONFIG_SIGNED_PE_FILE_VERIFICATION is not set
+
+#
+# Certificates for signature checking
+#
+CONFIG_MODULE_SIG_KEY="certs/signing_key.pem"
+CONFIG_SYSTEM_TRUSTED_KEYRING=y
+CONFIG_SYSTEM_TRUSTED_KEYS=""
+# CONFIG_SYSTEM_EXTRA_CERTIFICATE is not set
+# CONFIG_SECONDARY_TRUSTED_KEYRING is not set
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+CONFIG_CRC8=y
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_842_COMPRESS=y
+CONFIG_842_DECOMPRESS=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_COMPRESS=y
+CONFIG_LZ4HC_COMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_DMA_REMAP=y
+CONFIG_SGL_ALLOC=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_CLZ_TAB=y
+CONFIG_CORDIC=y
+CONFIG_DDR=y
+# CONFIG_IRQ_POLL is not set
+CONFIG_MPILIB=y
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_FONT_SUPPORT=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+CONFIG_FONT_ACORN_8x8=y
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_6x10 is not set
+# CONFIG_FONT_10x18 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_TER16x32 is not set
+CONFIG_ARCH_NO_SG_CHAIN=y
+CONFIG_SBITMAP=y
+# CONFIG_STRING_SELFTEST is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_GDB_SCRIPTS is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+CONFIG_UNUSED_SYMBOLS=y
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_SECTION_MISMATCH=y
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_CC_HAS_KASAN_GENERIC=y
+CONFIG_KASAN_STACK=1
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_SOFTLOCKUP_DETECTOR is not set
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+CONFIG_NOTIFIER_ERROR_INJECTION=y
+# CONFIG_PM_NOTIFIER_ERROR_INJECT is not set
+# CONFIG_NETDEV_NOTIFIER_ERROR_INJECT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_RUNTIME_TESTING_MENU=y
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_BITFIELD is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_XARRAY is not set
+# CONFIG_TEST_OVERFLOW is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_TEST_IDA is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_FIND_BIT_BENCHMARK is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_SYSCTL is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_TEST_MEMCAT_P is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_UBSAN is not set
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_IO_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP_DEBUGFS is not set
+# CONFIG_DEBUG_WX is not set
+# CONFIG_UNWINDER_FRAME_POINTER is not set
+CONFIG_UNWINDER_ARM=y
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+CONFIG_UNCOMPRESS_INCLUDE="mach/uncompress.h"
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_CORESIGHT is not set
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/kernel/smp.c linux-3ds/arch/arm/kernel/smp.c
--- linux-5.0.3/arch/arm/kernel/smp.c	2019-03-19 09:10:58.000000000 -0300
+++ linux-3ds/arch/arm/kernel/smp.c	2019-05-04 18:53:35.901332400 -0300
@@ -523,7 +523,7 @@
 	S(IPI_COMPLETION, "completion interrupts"),
 };
 
-static void smp_cross_call(const struct cpumask *target, unsigned int ipinr)
+void smp_cross_call(const struct cpumask *target, unsigned int ipinr)
 {
 	trace_ipi_raise_rcuidle(target, ipi_types[ipinr]);
 	__smp_cross_call(target, ipinr);
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/Makefile linux-3ds/arch/arm/mach-nintendo3ds/Makefile
--- linux-5.0.3/arch/arm/mach-nintendo3ds/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/Makefile	2019-05-04 18:53:35.903340500 -0300
@@ -0,0 +1,4 @@
+obj-$(CONFIG_ARCH_NINTENDO3DS) += nintendo3ds_ctr.o
+obj-$(CONFIG_ARCH_NINTENDO3DS) += bottom_lcd.o
+obj-$(CONFIG_SMP) += platsmp.o
+obj-$(CONFIG_SMP) += headsmp.o
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/Makefile.boot linux-3ds/arch/arm/mach-nintendo3ds/Makefile.boot
--- linux-5.0.3/arch/arm/mach-nintendo3ds/Makefile.boot	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/Makefile.boot	2019-05-04 18:53:35.904324500 -0300
@@ -0,0 +1,3 @@
+zreladdr-y     += 0x20008000
+params_phys-y  := 0x20000100
+initrd_phys-y  := 0x20000000
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/bottom_lcd.c linux-3ds/arch/arm/mach-nintendo3ds/bottom_lcd.c
--- linux-5.0.3/arch/arm/mach-nintendo3ds/bottom_lcd.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/bottom_lcd.c	2019-05-04 18:53:35.909379400 -0300
@@ -0,0 +1,144 @@
+/*
+ *  Nintendo 3DS bottom_lcd.c
+ *
+ *  Copyright (C) 2016 Sergi Granell
+ *  Copyright (C) 2017 Paul LaMendola (paulguy)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/ioport.h>
+#include <mach/platform.h>
+#include <mach/bottom_lcd.h>
+
+static u8 __iomem *bottom_lcd_fb = NULL;
+
+void nintendo3ds_bottom_setup_fb(void)
+{
+	u8 __iomem *lcd_fb_pdc1_base;
+
+	if (request_mem_region(NINTENDO3DS_GPU_REG_LCD_FB_PDC1, NINTENDO3DS_GPU_REG_LCD_FB_PDC_SIZE, "N3DS_LCD_FB_PDC1")) {
+		lcd_fb_pdc1_base = ioremap_nocache(NINTENDO3DS_GPU_REG_LCD_FB_PDC1, NINTENDO3DS_GPU_REG_LCD_FB_PDC_SIZE);
+
+		printk("LCD_FB_PDC1 mapped to: %p - %p\n", lcd_fb_pdc1_base,
+			lcd_fb_pdc1_base +
+			NINTENDO3DS_GPU_REG_LCD_FB_PDC_SIZE);
+	} else {
+		printk("LCD_FB_PDC1 region not available.\n");
+		return;
+	}
+
+	iowrite32((NINTENDO3DS_LCD_BOT_HEIGHT << 16)
+		| NINTENDO3DS_LCD_TOP_WIDTH, lcd_fb_pdc1_base + 0x5C);
+	iowrite32(NINTENDO3DS_FB_BOT_1, lcd_fb_pdc1_base + 0x68);
+	iowrite32(NINTENDO3DS_FB_BOT_2, lcd_fb_pdc1_base + 0x6C);
+	iowrite32(0b000001, lcd_fb_pdc1_base + 0x70);
+	iowrite32(0, lcd_fb_pdc1_base + 0x78);
+	iowrite32(NINTENDO3DS_LCD_BOT_HEIGHT * 3, lcd_fb_pdc1_base + 0x90);
+
+	iounmap(lcd_fb_pdc1_base);
+	release_mem_region(NINTENDO3DS_GPU_REG_LCD_FB_PDC1,
+		NINTENDO3DS_GPU_REG_LCD_FB_PDC_SIZE);
+}
+
+void nintendo3ds_bottom_lcd_map_fb(void)
+{
+	/* Map bottom screen framebuffer (VRAM) */
+	if (request_mem_region(NINTENDO3DS_FB_BOT_1, NINTENDO3DS_FB_BOT_SIZE, "N3DS_BOT_FB")) {
+		bottom_lcd_fb = ioremap_nocache(NINTENDO3DS_FB_BOT_1, NINTENDO3DS_FB_BOT_SIZE);
+
+		printk("Nintendo 3DS: Bottom LCD FB mapped to: %p - %p\n",
+			bottom_lcd_fb, bottom_lcd_fb + NINTENDO3DS_FB_BOT_SIZE);
+	} else {
+		printk("Nintendo 3DS: Bottom LCD FB region not available.\n");
+	}
+}
+
+void nintendo3ds_bottom_lcd_unmap_fb(void)
+{
+	if (bottom_lcd_fb) {
+		iounmap(bottom_lcd_fb);
+		release_mem_region(NINTENDO3DS_FB_BOT_1, NINTENDO3DS_FB_BOT_SIZE);
+	}
+}
+
+void nintendo3ds_bottom_lcd_draw_pixel(int x, int y, unsigned int color)
+{
+	u8 __iomem *dst;
+
+	if (x < 0 || y < 0)
+		return;
+
+	dst = bottom_lcd_fb + ((NINTENDO3DS_LCD_BOT_HEIGHT - y - 1) +
+		x * NINTENDO3DS_LCD_BOT_HEIGHT) * 3;
+	iowrite8((color >> 0 ) & 0xFF, dst + 0);
+	iowrite8((color >> 8 ) & 0xFF, dst + 1);
+	iowrite8((color >> 16) & 0xFF, dst + 2);
+}
+
+void nintendo3ds_bottom_lcd_draw_fillrect(int x, int y, int w, int h, unsigned int color)
+{
+	int i, j;
+	for (i = 0; i < h; i++)
+		for (j = 0; j < w; j++)
+			nintendo3ds_bottom_lcd_draw_pixel(x + j, y + i, color);
+}
+
+void nintendo3ds_bottom_lcd_clear_screen(unsigned int color)
+{
+	nintendo3ds_bottom_lcd_draw_fillrect(0, 0, NINTENDO3DS_LCD_BOT_WIDTH, NINTENDO3DS_LCD_BOT_HEIGHT, color);
+}
+
+void nintendo3ds_bottom_lcd_draw_char(const struct font_desc *font, int x, int y, unsigned int color, char c)
+{
+	int i, j;
+	const u8 *src;
+
+	src = font->data + c * font->height;
+
+	for (i = 0; i < 8; i++) {
+		for (j = 0; j < 8; j++) {
+			if ((*src & (128 >> j)))
+				nintendo3ds_bottom_lcd_draw_pixel(x+j, y+i, color);
+		}
+		src++;
+	}
+}
+
+int nintendo3ds_bottom_lcd_draw_text(const struct font_desc *font, int x, int y, unsigned int fgcolor, unsigned int bgcolor, const char *text)
+{
+	char c;
+	int sx = x;
+
+	if (!text)
+		return 0;
+
+	while ((c = *text++)) {
+		if (c == '\n') {
+			x = sx;
+			y += font->height;
+		} else if (c == ' ') {
+			x += font->width;
+		} else if(c == '\t') {
+			x += 4 * font->width;
+		} else {
+			nintendo3ds_bottom_lcd_draw_fillrect(x, y, font->width, font->height, bgcolor);
+			nintendo3ds_bottom_lcd_draw_char(font, x, y, fgcolor, c);
+			x += font->width;
+		}
+	}
+
+	return x - sx;
+}
+
+void nintendo3ds_bottom_lcd_draw_textf(const struct font_desc *font, int x, int y, unsigned int fgcolor, unsigned int bgcolor, const char *text, ...)
+{
+	char buffer[256];
+	va_list args;
+	va_start(args, text);
+	vsnprintf(buffer, 256, text, args);
+	nintendo3ds_bottom_lcd_draw_text(font, x, y, bgcolor, fgcolor, buffer);
+	va_end(args);
+}
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/headsmp.S linux-3ds/arch/arm/mach-nintendo3ds/headsmp.S
--- linux-5.0.3/arch/arm/mach-nintendo3ds/headsmp.S	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/headsmp.S	2019-05-04 18:53:35.912363300 -0300
@@ -0,0 +1,38 @@
+/*
+ *  linux/arch/arm/mach-nintendo3ds/headsmp.S
+ *
+ *  Cloned from linux/arch/arm/plat-versatile/headsmp.S
+ *
+ *  Copyright (c) 2016 Sergi Granell <xerpi.g.12@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+/*
+ * CPU1 comes with the cache dirty from the bootrom,
+ * so clean the cache before jumping to the kernel.
+ */
+
+ENTRY(nintendo3ds_secondary_startup)
+	cpsid aif
+
+	mov r0, #0
+
+	/* Invalidate Both Caches & flush the branch target cache */
+	mcr p15, 0, r0, c7, c7, 0
+
+	/* Flush Prefetch Buffer */
+	mcr p15, 0, r0, c7, c5, 4
+
+	/* Flush Entire Branch Target Cache */
+	mcr p15, 0, r0, c7, c5, 6
+
+	/* Data Synchronization Barrier */
+	mcr p15, 0, r0, c7, c10, 4
+
+    b secondary_startup
+ENDPROC(nintendo3ds_secondary_startup)
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/bottom_lcd.h linux-3ds/arch/arm/mach-nintendo3ds/include/mach/bottom_lcd.h
--- linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/bottom_lcd.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/bottom_lcd.h	2019-05-04 18:53:35.914358600 -0300
@@ -0,0 +1,42 @@
+/*
+ *  Nintendo 3DS bottom_lcd.h
+ *
+ *  Copyright (C) 2016 Sergi Granell
+ *  Copyright (C) 2017 Paul LaMendola (paulguy)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __NINTENDO3DS_BOTTOM_LCD_H
+#define __NINTENDO3DS_BOTTOM_LCD_H
+
+#include <linux/font.h>
+#include <asm/io.h>
+
+#define COLOR_RED		0xFF0000
+#define COLOR_GREEN		0x00FF00
+#define COLOR_BLUE		0x0000FF
+#define COLOR_CYAN		0x00FFFF
+#define COLOR_PINK		0xFF00FF
+#define COLOR_YELLOW		0xFFFF00
+#define COLOR_BLACK		0x000000
+#define COLOR_GREY		0x808080
+#define COLOR_WHITE		0xFFFFFF
+#define COLOR_ORANGE		0xFF9900
+#define COLOR_LIGHT_GREEN	0x00CC00
+#define COLOR_PURPLE		0x660033
+
+void nintendo3ds_bottom_setup_fb(void);
+void nintendo3ds_bottom_lcd_map_fb(void);
+void nintendo3ds_bottom_lcd_unmap_fb(void);
+
+void nintendo3ds_bottom_lcd_draw_pixel(int x, int y, unsigned int color);
+void nintendo3ds_bottom_lcd_draw_fillrect(int x, int y, int w, int h, unsigned int color);
+void nintendo3ds_bottom_lcd_clear_screen(unsigned int color);
+void nintendo3ds_bottom_lcd_draw_char(const struct font_desc *font, int x, int y, unsigned int color, char c);
+int nintendo3ds_bottom_lcd_draw_text(const struct font_desc *font, int x, int y, unsigned int fgcolor, unsigned int bgcolor, const char *text);
+void nintendo3ds_bottom_lcd_draw_textf(const struct font_desc *font, int x, int y, unsigned int fgcolor, unsigned int bgcolor, const char *text, ...);
+
+#endif
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/debug-macro.S linux-3ds/arch/arm/mach-nintendo3ds/include/mach/debug-macro.S
--- linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/debug-macro.S	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/debug-macro.S	2019-05-04 18:53:35.917346800 -0300
@@ -0,0 +1,47 @@
+#ifdef CONFIG_DEBUG_LL_NINTENDO3DS_ARM9
+
+#define EARLY_SHARED_BUF_PA (0x20000000)
+
+.macro	addruart,rp,rv,tmp
+	mov	\rp, #EARLY_SHARED_BUF_PA
+	mov	\rv, #(EARLY_SHARED_BUF_PA - CONFIG_PHYS_OFFSET + CONFIG_PAGE_OFFSET)
+.endm
+
+.macro	senduart,rd,rx
+	strb	\rd, [\rx]
+	# Clean and Invalidate Entire Data Cache
+	# Data Synchronization Barrier
+	mov	\rd, #0
+	mcr	p15, 0, \rd, c7, c14, 0
+	mcr 	p15, 0, \rd, c7, c10, 4
+.endm
+
+.macro	busyuart,rd,rx
+99:
+	# Invalidate Entire Data Cache
+	mov	\rd, #0
+	mcr	p15, 0, \rd, c7, c6, 0
+
+	ldrb	\rd, [\rx]
+	cmp	\rd, #0
+	bne	99b
+.endm
+
+.macro	waituart,rd,rx
+.endm
+
+#else
+
+.macro	addruart,rp,rv,tmp
+.endm
+
+.macro	senduart,rd,rx
+.endm
+
+.macro	busyuart,rd,rx
+.endm
+
+.macro	waituart,rd,rx
+.endm
+
+#endif
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/entry-macro.S linux-3ds/arch/arm/mach-nintendo3ds/include/mach/entry-macro.S
--- linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/entry-macro.S	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/entry-macro.S	2019-05-04 18:53:35.918336100 -0300
@@ -0,0 +1,12 @@
+
+
+.macro  get_irqnr_preamble, base, tmp
+ldr	\base, =0
+.endm
+
+.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+ldr	\irqstat, [\base, #0]
+clz	\irqnr, \irqstat
+rsb	\irqnr, \irqnr, #31
+teq	\irqstat, #0
+.endm
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/hardware.h linux-3ds/arch/arm/mach-nintendo3ds/include/mach/hardware.h
--- linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/hardware.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/hardware.h	2019-05-04 18:53:35.919352800 -0300
@@ -0,0 +1,21 @@
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+
+/* macro to get at IO space when running virtually */
+#ifdef CONFIG_MMU
+/*
+ * Statically mapped addresses:
+ *
+ * 10xx xxxx -> fbxx xxxx
+ * 1exx xxxx -> fdxx xxxx
+ * 1fxx xxxx -> fexx xxxx
+ */
+#define IO_ADDRESS(x)		(((x) & 0x03ffffff) + 0xfb000000)
+#else
+#define IO_ADDRESS(x)		(x)
+#endif
+#define __io_address(n)		IOMEM(IO_ADDRESS(n))
+
+#endif
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/irqs.h linux-3ds/arch/arm/mach-nintendo3ds/include/mach/irqs.h
--- linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/irqs.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/irqs.h	2019-05-04 18:53:35.920333700 -0300
@@ -0,0 +1,8 @@
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+
+#define NR_IRQS 128
+
+
+#endif
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/platform.h linux-3ds/arch/arm/mach-nintendo3ds/include/mach/platform.h
--- linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/platform.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/platform.h	2019-05-11 19:16:55.994734800 -0300
@@ -0,0 +1,44 @@
+#ifndef __ASM_ARCH_PLATFORM_H
+#define __ASM_ARCH_PLATFORM_H
+
+
+/* Memory layout */
+
+#define NINTENDO3DS_CTR_VRAM_BASE	(0x18000000)
+#define NINTENDO3DS_CTR_VRAM_SIZE	(0x00600000)
+#define NINTENDO3DS_CTR_AXI_WRAM_BASE	(0x1FF80000)
+#define NINTENDO3DS_CTR_AXI_WRAM_SIZE	(0x00080000)
+#define NINTENDO3DS_CTR_FCRAM_BASE	(0x20000000)
+#define NINTENDO3DS_CTR_FCRAM_SIZE	(0x08000000)
+
+/* PDN Registers */
+
+#define NINTENDO3DS_REG_PDN_SPI_CNT	(0x101401C0)
+
+/* GPU External registers */
+
+#define NINTENDO3DS_LCD_TOP_WIDTH	(400)
+#define NINTENDO3DS_LCD_BOT_WIDTH	(320)
+#define NINTENDO3DS_LCD_TOP_HEIGHT	(240)
+#define NINTENDO3DS_LCD_BOT_HEIGHT	(240)
+
+#define NINTENDO3DS_GPU_REG_LCD_FB_PDC0		(0x10400400)
+#define NINTENDO3DS_GPU_REG_LCD_FB_PDC1		(0x10400500)
+
+#define NINTENDO3DS_GPU_REG_LCD_FB_PDC_SIZE		(0x100)
+
+#define NINTENDO3DS_GPU_REG_LCD_FB_A_ADDR_OFFSET	(0x68)
+#define NINTENDO3DS_GPU_REG_LCD_FB_B_ADDR_OFFSET 	(0x94)
+
+/* Framebuffer setup */
+
+#define NINTENDO3DS_FB_TOP_SIZE		(NINTENDO3DS_LCD_TOP_WIDTH * NINTENDO3DS_LCD_TOP_HEIGHT * 3)
+#define NINTENDO3DS_FB_BOT_SIZE		(NINTENDO3DS_LCD_TOP_WIDTH * NINTENDO3DS_LCD_TOP_HEIGHT * 3)
+#define NINTENDO3DS_FB_TOP_LEFT1	(NINTENDO3DS_CTR_VRAM_BASE)
+#define NINTENDO3DS_FB_TOP_LEFT2	(NINTENDO3DS_FB_TOP_LEFT1  + NINTENDO3DS_FB_TOP_SIZE)
+#define NINTENDO3DS_FB_TOP_RIGHT1	(NINTENDO3DS_FB_TOP_LEFT2  + NINTENDO3DS_FB_TOP_SIZE)
+#define NINTENDO3DS_FB_TOP_RIGHT2	(NINTENDO3DS_FB_TOP_RIGHT1 + NINTENDO3DS_FB_TOP_SIZE)
+#define NINTENDO3DS_FB_BOT_1		(NINTENDO3DS_FB_TOP_RIGHT2 + NINTENDO3DS_FB_TOP_SIZE)
+#define NINTENDO3DS_FB_BOT_2		(NINTENDO3DS_FB_BOT_1      + NINTENDO3DS_FB_BOT_SIZE)
+
+#endif	/* __ASM_ARCH_PLATFORM_H */
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/platsmp.h linux-3ds/arch/arm/mach-nintendo3ds/include/mach/platsmp.h
--- linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/platsmp.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/platsmp.h	2019-05-04 18:53:35.929309100 -0300
@@ -0,0 +1,11 @@
+/*
+ *  linux/arch/arm/mach-nintendo3ds/include/mach/platsmp.h
+ *
+ *  Copyright (c) 2016 Sergi Granell <xerpi.g.12@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+extern void nintendo3ds_secondary_startup(void);
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/pxi.h linux-3ds/arch/arm/mach-nintendo3ds/include/mach/pxi.h
--- linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/pxi.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/pxi.h	2019-05-04 18:53:35.930307200 -0300
@@ -0,0 +1,36 @@
+/*
+ *  pxi.h
+ *
+ *  Copyright (C) 2016 Sergi Granell <xerpi.g.12@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __NINTENDO3DS_PXI_H
+#define __NINTENDO3DS_PXI_H
+
+#include <linux/types.h>
+
+struct pxi_channel;
+struct pxi_controller;
+
+struct pxi_message;
+
+struct pxi_channel *pxi_acq_channel(struct device *dev,
+									struct pxi_controller *pxi,
+									const char *devname);
+int pxi_rel_channel(struct pxi_channel *chan);
+
+struct pxi_message *pxi_alloc_message(struct pxi_channel *chan,
+										u8 function, u32 argc);
+void pxi_free_message(struct pxi_channel *chan, struct pxi_message *msg);
+
+int pxi_send_message(struct pxi_channel *chan, struct pxi_message *msg);
+
+int pxi_set_fn(struct pxi_message *msg, u8 fn);
+int pxi_set_arg(struct pxi_message *msg, unsigned i, u32 val);
+int pxi_get_arg(struct pxi_message *msg, unsigned i, u32 *val);
+
+#endif
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/uncompress.h linux-3ds/arch/arm/mach-nintendo3ds/include/mach/uncompress.h
--- linux-5.0.3/arch/arm/mach-nintendo3ds/include/mach/uncompress.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/uncompress.h	2019-05-04 18:53:35.933304100 -0300
@@ -0,0 +1,208 @@
+//#include <mach/nintendo3ds.h>
+
+#define VRAM_BASE             (0x18000000)
+#define FB_BASE_PA            (VRAM_BASE)
+#define FB_TOP_SIZE           (400*240*3)
+#define FB_BOT_SIZE           (320*240*3)
+#define FB_TOP_LEFT1          (FB_BASE_PA)
+#define FB_TOP_LEFT2          (FB_TOP_LEFT1  + FB_TOP_SIZE)
+#define FB_TOP_RIGHT1         (FB_TOP_LEFT2  + FB_TOP_SIZE)
+#define FB_TOP_RIGHT2         (FB_TOP_RIGHT1 + FB_TOP_SIZE)
+#define FB_BOT_1              (FB_TOP_RIGHT2 + FB_TOP_SIZE)
+#define FB_BOT_2              (FB_BOT_1      + FB_BOT_SIZE)
+#define SCREEN_TOP_W  (400)
+#define SCREEN_BOT_W  (320)
+#define SCREEN_TOP_H  (240)
+#define SCREEN_BOT_H  (240)
+
+#define RED	   0xFF0000
+#define GREEN  0x00FF00
+#define BLUE   0x0000FF
+#define CYAN   0x00FFFF
+#define BLACK  0x000000
+#define WHITE  0xFFFFFF
+
+static const unsigned char msx_font[] __attribute((aligned(4))) =
+"\x00\x00\x00\x00\x00\x00\x00\x00\x3c\x42\xa5\x81\xa5\x99\x42\x3c"
+"\x3c\x7e\xdb\xff\xff\xdb\x66\x3c\x6c\xfe\xfe\xfe\x7c\x38\x10\x00"
+"\x10\x38\x7c\xfe\x7c\x38\x10\x00\x10\x38\x54\xfe\x54\x10\x38\x00"
+"\x10\x38\x7c\xfe\xfe\x10\x38\x00\x00\x00\x00\x30\x30\x00\x00\x00"
+"\xff\xff\xff\xe7\xe7\xff\xff\xff\x38\x44\x82\x82\x82\x44\x38\x00"
+"\xc7\xbb\x7d\x7d\x7d\xbb\xc7\xff\x0f\x03\x05\x79\x88\x88\x88\x70"
+"\x38\x44\x44\x44\x38\x10\x7c\x10\x30\x28\x24\x24\x28\x20\xe0\xc0"
+"\x3c\x24\x3c\x24\x24\xe4\xdc\x18\x10\x54\x38\xee\x38\x54\x10\x00"
+"\x10\x10\x10\x7c\x10\x10\x10\x10\x10\x10\x10\xff\x00\x00\x00\x00"
+"\x00\x00\x00\xff\x10\x10\x10\x10\x10\x10\x10\xf0\x10\x10\x10\x10"
+"\x10\x10\x10\x1f\x10\x10\x10\x10\x10\x10\x10\xff\x10\x10\x10\x10"
+"\x10\x10\x10\x10\x10\x10\x10\x10\x00\x00\x00\xff\x00\x00\x00\x00"
+"\x00\x00\x00\x1f\x10\x10\x10\x10\x00\x00\x00\xf0\x10\x10\x10\x10"
+"\x10\x10\x10\x1f\x00\x00\x00\x00\x10\x10\x10\xf0\x00\x00\x00\x00"
+"\x81\x42\x24\x18\x18\x24\x42\x81\x01\x02\x04\x08\x10\x20\x40\x80"
+"\x80\x40\x20\x10\x08\x04\x02\x01\x00\x10\x10\xff\x10\x10\x00\x00"
+"\x00\x00\x00\x00\x00\x00\x00\x00\x20\x20\x20\x20\x00\x00\x20\x00"
+"\x50\x50\x50\x00\x00\x00\x00\x00\x50\x50\xf8\x50\xf8\x50\x50\x00"
+"\x20\x78\xa0\x70\x28\xf0\x20\x00\xc0\xc8\x10\x20\x40\x98\x18\x00"
+"\x40\xa0\x40\xa8\x90\x98\x60\x00\x10\x20\x40\x00\x00\x00\x00\x00"
+"\x10\x20\x40\x40\x40\x20\x10\x00\x40\x20\x10\x10\x10\x20\x40\x00"
+"\x20\xa8\x70\x20\x70\xa8\x20\x00\x00\x20\x20\xf8\x20\x20\x00\x00"
+"\x00\x00\x00\x00\x00\x20\x20\x40\x00\x00\x00\x78\x00\x00\x00\x00"
+"\x00\x00\x00\x00\x00\x60\x60\x00\x00\x00\x08\x10\x20\x40\x80\x00"
+"\x70\x88\x98\xa8\xc8\x88\x70\x00\x20\x60\xa0\x20\x20\x20\xf8\x00"
+"\x70\x88\x08\x10\x60\x80\xf8\x00\x70\x88\x08\x30\x08\x88\x70\x00"
+"\x10\x30\x50\x90\xf8\x10\x10\x00\xf8\x80\xe0\x10\x08\x10\xe0\x00"
+"\x30\x40\x80\xf0\x88\x88\x70\x00\xf8\x88\x10\x20\x20\x20\x20\x00"
+"\x70\x88\x88\x70\x88\x88\x70\x00\x70\x88\x88\x78\x08\x10\x60\x00"
+"\x00\x00\x20\x00\x00\x20\x00\x00\x00\x00\x20\x00\x00\x20\x20\x40"
+"\x18\x30\x60\xc0\x60\x30\x18\x00\x00\x00\xf8\x00\xf8\x00\x00\x00"
+"\xc0\x60\x30\x18\x30\x60\xc0\x00\x70\x88\x08\x10\x20\x00\x20\x00"
+"\x70\x88\x08\x68\xa8\xa8\x70\x00\x20\x50\x88\x88\xf8\x88\x88\x00"
+"\xf0\x48\x48\x70\x48\x48\xf0\x00\x30\x48\x80\x80\x80\x48\x30\x00"
+"\xe0\x50\x48\x48\x48\x50\xe0\x00\xf8\x80\x80\xf0\x80\x80\xf8\x00"
+"\xf8\x80\x80\xf0\x80\x80\x80\x00\x70\x88\x80\xb8\x88\x88\x70\x00"
+"\x88\x88\x88\xf8\x88\x88\x88\x00\x70\x20\x20\x20\x20\x20\x70\x00"
+"\x38\x10\x10\x10\x90\x90\x60\x00\x88\x90\xa0\xc0\xa0\x90\x88\x00"
+"\x80\x80\x80\x80\x80\x80\xf8\x00\x88\xd8\xa8\xa8\x88\x88\x88\x00"
+"\x88\xc8\xc8\xa8\x98\x98\x88\x00\x70\x88\x88\x88\x88\x88\x70\x00"
+"\xf0\x88\x88\xf0\x80\x80\x80\x00\x70\x88\x88\x88\xa8\x90\x68\x00"
+"\xf0\x88\x88\xf0\xa0\x90\x88\x00\x70\x88\x80\x70\x08\x88\x70\x00"
+"\xf8\x20\x20\x20\x20\x20\x20\x00\x88\x88\x88\x88\x88\x88\x70\x00"
+"\x88\x88\x88\x88\x50\x50\x20\x00\x88\x88\x88\xa8\xa8\xd8\x88\x00"
+"\x88\x88\x50\x20\x50\x88\x88\x00\x88\x88\x88\x70\x20\x20\x20\x00"
+"\xf8\x08\x10\x20\x40\x80\xf8\x00\x70\x40\x40\x40\x40\x40\x70\x00"
+"\x00\x00\x80\x40\x20\x10\x08\x00\x70\x10\x10\x10\x10\x10\x70\x00"
+"\x20\x50\x88\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf8\x00"
+"\x40\x20\x10\x00\x00\x00\x00\x00\x00\x00\x70\x08\x78\x88\x78\x00"
+"\x80\x80\xb0\xc8\x88\xc8\xb0\x00\x00\x00\x70\x88\x80\x88\x70\x00"
+"\x08\x08\x68\x98\x88\x98\x68\x00\x00\x00\x70\x88\xf8\x80\x70\x00"
+"\x10\x28\x20\xf8\x20\x20\x20\x00\x00\x00\x68\x98\x98\x68\x08\x70"
+"\x80\x80\xf0\x88\x88\x88\x88\x00\x20\x00\x60\x20\x20\x20\x70\x00"
+"\x10\x00\x30\x10\x10\x10\x90\x60\x40\x40\x48\x50\x60\x50\x48\x00"
+"\x60\x20\x20\x20\x20\x20\x70\x00\x00\x00\xd0\xa8\xa8\xa8\xa8\x00"
+"\x00\x00\xb0\xc8\x88\x88\x88\x00\x00\x00\x70\x88\x88\x88\x70\x00"
+"\x00\x00\xb0\xc8\xc8\xb0\x80\x80\x00\x00\x68\x98\x98\x68\x08\x08"
+"\x00\x00\xb0\xc8\x80\x80\x80\x00\x00\x00\x78\x80\xf0\x08\xf0\x00"
+"\x40\x40\xf0\x40\x40\x48\x30\x00\x00\x00\x90\x90\x90\x90\x68\x00"
+"\x00\x00\x88\x88\x88\x50\x20\x00\x00\x00\x88\xa8\xa8\xa8\x50\x00"
+"\x00\x00\x88\x50\x20\x50\x88\x00\x00\x00\x88\x88\x98\x68\x08\x70"
+"\x00\x00\xf8\x10\x20\x40\xf8\x00\x18\x20\x20\x40\x20\x20\x18\x00"
+"\x20\x20\x20\x00\x20\x20\x20\x00\xc0\x20\x20\x10\x20\x20\xc0\x00"
+"\x40\xa8\x10\x00\x00\x00\x00\x00\x00\x00\x20\x50\xf8\x00\x00\x00"
+"\x70\x88\x80\x80\x88\x70\x20\x60\x90\x00\x00\x90\x90\x90\x68\x00"
+"\x10\x20\x70\x88\xf8\x80\x70\x00\x20\x50\x70\x08\x78\x88\x78\x00"
+"\x48\x00\x70\x08\x78\x88\x78\x00\x20\x10\x70\x08\x78\x88\x78\x00"
+"\x20\x00\x70\x08\x78\x88\x78\x00\x00\x70\x80\x80\x80\x70\x10\x60"
+"\x20\x50\x70\x88\xf8\x80\x70\x00\x50\x00\x70\x88\xf8\x80\x70\x00"
+"\x20\x10\x70\x88\xf8\x80\x70\x00\x50\x00\x00\x60\x20\x20\x70\x00"
+"\x20\x50\x00\x60\x20\x20\x70\x00\x40\x20\x00\x60\x20\x20\x70\x00"
+"\x50\x00\x20\x50\x88\xf8\x88\x00\x20\x00\x20\x50\x88\xf8\x88\x00"
+"\x10\x20\xf8\x80\xf0\x80\xf8\x00\x00\x00\x6c\x12\x7e\x90\x6e\x00"
+"\x3e\x50\x90\x9c\xf0\x90\x9e\x00\x60\x90\x00\x60\x90\x90\x60\x00"
+"\x90\x00\x00\x60\x90\x90\x60\x00\x40\x20\x00\x60\x90\x90\x60\x00"
+"\x40\xa0\x00\xa0\xa0\xa0\x50\x00\x40\x20\x00\xa0\xa0\xa0\x50\x00"
+"\x90\x00\x90\x90\xb0\x50\x10\xe0\x50\x00\x70\x88\x88\x88\x70\x00"
+"\x50\x00\x88\x88\x88\x88\x70\x00\x20\x20\x78\x80\x80\x78\x20\x20"
+"\x18\x24\x20\xf8\x20\xe2\x5c\x00\x88\x50\x20\xf8\x20\xf8\x20\x00"
+"\xc0\xa0\xa0\xc8\x9c\x88\x88\x8c\x18\x20\x20\xf8\x20\x20\x20\x40"
+"\x10\x20\x70\x08\x78\x88\x78\x00\x10\x20\x00\x60\x20\x20\x70\x00"
+"\x20\x40\x00\x60\x90\x90\x60\x00\x20\x40\x00\x90\x90\x90\x68\x00"
+"\x50\xa0\x00\xa0\xd0\x90\x90\x00\x28\x50\x00\xc8\xa8\x98\x88\x00"
+"\x00\x70\x08\x78\x88\x78\x00\xf8\x00\x60\x90\x90\x90\x60\x00\xf0"
+"\x20\x00\x20\x40\x80\x88\x70\x00\x00\x00\x00\xf8\x80\x80\x00\x00"
+"\x00\x00\x00\xf8\x08\x08\x00\x00\x84\x88\x90\xa8\x54\x84\x08\x1c"
+"\x84\x88\x90\xa8\x58\xa8\x3c\x08\x20\x00\x00\x20\x20\x20\x20\x00"
+"\x00\x00\x24\x48\x90\x48\x24\x00\x00\x00\x90\x48\x24\x48\x90\x00"
+"\x28\x50\x20\x50\x88\xf8\x88\x00\x28\x50\x70\x08\x78\x88\x78\x00"
+"\x28\x50\x00\x70\x20\x20\x70\x00\x28\x50\x00\x20\x20\x20\x70\x00"
+"\x28\x50\x00\x70\x88\x88\x70\x00\x50\xa0\x00\x60\x90\x90\x60\x00"
+"\x28\x50\x00\x88\x88\x88\x70\x00\x50\xa0\x00\xa0\xa0\xa0\x50\x00"
+"\xfc\x48\x48\x48\xe8\x08\x50\x20\x00\x50\x00\x50\x50\x50\x10\x20"
+"\xc0\x44\xc8\x54\xec\x54\x9e\x04\x10\xa8\x40\x00\x00\x00\x00\x00"
+"\x00\x20\x50\x88\x50\x20\x00\x00\x88\x10\x20\x40\x80\x28\x00\x00"
+"\x7c\xa8\xa8\x68\x28\x28\x28\x00\x38\x40\x30\x48\x48\x30\x08\x70"
+"\x00\x00\x00\x00\x00\x00\xff\xff\xf0\xf0\xf0\xf0\x0f\x0f\x0f\x0f"
+"\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00"
+"\x00\x00\x00\x3c\x3c\x00\x00\x00\xff\xff\xff\xff\xff\xff\x00\x00"
+"\xc0\xc0\xc0\xc0\xc0\xc0\xc0\xc0\x0f\x0f\x0f\x0f\xf0\xf0\xf0\xf0"
+"\xfc\xfc\xfc\xfc\xfc\xfc\xfc\xfc\x03\x03\x03\x03\x03\x03\x03\x03"
+"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x11\x22\x44\x88\x11\x22\x44\x88"
+"\x88\x44\x22\x11\x88\x44\x22\x11\xfe\x7c\x38\x10\x00\x00\x00\x00"
+"\x00\x00\x00\x00\x10\x38\x7c\xfe\x80\xc0\xe0\xf0\xe0\xc0\x80\x00"
+"\x01\x03\x07\x0f\x07\x03\x01\x00\xff\x7e\x3c\x18\x18\x3c\x7e\xff"
+"\x81\xc3\xe7\xff\xff\xe7\xc3\x81\xf0\xf0\xf0\xf0\x00\x00\x00\x00"
+"\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x00\x00\x00\x00"
+"\x00\x00\x00\x00\xf0\xf0\xf0\xf0\x33\x33\xcc\xcc\x33\x33\xcc\xcc"
+"\x00\x20\x20\x50\x50\x88\xf8\x00\x20\x20\x70\x20\x70\x20\x20\x00"
+"\x00\x00\x00\x50\x88\xa8\x50\x00\xff\xff\xff\xff\xff\xff\xff\xff"
+"\x00\x00\x00\x00\xff\xff\xff\xff\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0"
+"\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\xff\xff\xff\xff\x00\x00\x00\x00"
+"\x00\x00\x68\x90\x90\x90\x68\x00\x30\x48\x48\x70\x48\x48\x70\xc0"
+"\xf8\x88\x80\x80\x80\x80\x80\x00\xf8\x50\x50\x50\x50\x50\x98\x00"
+"\xf8\x88\x40\x20\x40\x88\xf8\x00\x00\x00\x78\x90\x90\x90\x60\x00"
+"\x00\x50\x50\x50\x50\x68\x80\x80\x00\x50\xa0\x20\x20\x20\x20\x00"
+"\xf8\x20\x70\xa8\xa8\x70\x20\xf8\x20\x50\x88\xf8\x88\x50\x20\x00"
+"\x70\x88\x88\x88\x50\x50\xd8\x00\x30\x40\x40\x20\x50\x50\x50\x20"
+"\x00\x00\x00\x50\xa8\xa8\x50\x00\x08\x70\xa8\xa8\xa8\x70\x80\x00"
+"\x38\x40\x80\xf8\x80\x40\x38\x00\x70\x88\x88\x88\x88\x88\x88\x00"
+"\x00\xf8\x00\xf8\x00\xf8\x00\x00\x20\x20\xf8\x20\x20\x00\xf8\x00"
+"\xc0\x30\x08\x30\xc0\x00\xf8\x00\x18\x60\x80\x60\x18\x00\xf8\x00"
+"\x10\x28\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\xa0\x40"
+"\x00\x20\x00\xf8\x00\x20\x00\x00\x00\x50\xa0\x00\x50\xa0\x00\x00"
+"\x00\x18\x24\x24\x18\x00\x00\x00\x00\x30\x78\x78\x30\x00\x00\x00"
+"\x00\x00\x00\x00\x30\x00\x00\x00\x3e\x20\x20\x20\xa0\x60\x20\x00"
+"\xa0\x50\x50\x50\x00\x00\x00\x00\x40\xa0\x20\x40\xe0\x00\x00\x00"
+"\x00\x38\x38\x38\x38\x38\x38\x00\x00\x00\x00\x00\x00\x00\x00";
+
+
+static void draw_plot(int x, int y, u32 color)
+{
+	u8 *base = (u8*)((SCREEN_TOP_H-y-1)*3 +x*3*SCREEN_TOP_H);
+	u8 *p1 = base + FB_TOP_LEFT1;
+	u8 *p2 = base + FB_TOP_LEFT2;
+	u8 *p3 = base + FB_TOP_RIGHT1;
+	u8 *p4 = base + FB_TOP_RIGHT2;
+	p1[0] = p2[0] = p3[0] = p4[0] = color & 0xFF;
+	p1[1] = p2[1] = p3[1] =	p4[1] = (color>>8) & 0xFF;
+	p1[2] = p2[2] = p3[2] =	p4[2] = (color>>16) & 0xFF;
+}
+
+static int font_draw_char(int x, int y, u32 color, char c)
+{
+	u8 *font = (u8*)(msx_font + c * 8);
+	int i, j;
+	for (i = 0; i < 8; ++i) {
+		for (j = 0; j < 8; ++j) {
+			draw_plot(x+j, y+i, BLACK);
+			if ((*font & (128 >> j))) draw_plot(x+j, y+i, color);
+		}
+		++font;
+	}
+	return x+8;
+}
+
+unsigned long cns_x, cns_y;
+
+static void putc(char c)
+{
+	if (c == '\n') {
+		cns_y += 10;
+	} else if (c == '\r'){
+		cns_x = 8;
+	} else if (c == '\t'){
+		cns_x += 8*4;
+	} else {
+		font_draw_char(cns_x, cns_y, WHITE, c);
+		cns_x += 8;
+	}
+	if (cns_x > (SCREEN_TOP_W-8)) cns_x = 8;
+	if (cns_y > (SCREEN_TOP_H-10)) cns_y = 8;
+}
+
+static void flush(void)
+{
+}
+
+static inline void arch_decomp_setup(void)
+{
+	cns_x = 8;
+	cns_y = 8;
+}
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/nintendo3ds_ctr.c linux-3ds/arch/arm/mach-nintendo3ds/nintendo3ds_ctr.c
--- linux-5.0.3/arch/arm/mach-nintendo3ds/nintendo3ds_ctr.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/nintendo3ds_ctr.c	2019-05-08 11:31:28.639761800 -0300
@@ -0,0 +1,52 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/irqchip/arm-gic.h>
+#include <linux/platform_device.h>
+
+#include <linux/clk-provider.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/smp_twd.h>
+
+#include <mach/hardware.h>
+#include <mach/platform.h>
+
+#include <mach/bottom_lcd.h>
+
+static void __init nintendo3ds_pdn_set_spi_new(void)
+{
+	void __iomem *pdn_spi_cnt;
+
+	pdn_spi_cnt = ioremap(NINTENDO3DS_REG_PDN_SPI_CNT, 4);
+	iowrite16(ioread16(pdn_spi_cnt) | 7, pdn_spi_cnt);
+	iounmap(pdn_spi_cnt);
+}
+
+static void __init nintendo3ds_ctr_dt_init_machine(void)
+{
+	printk("nintendo3ds_ctr_dt_init_machine\n");
+
+	nintendo3ds_bottom_setup_fb();
+	nintendo3ds_bottom_lcd_map_fb();
+	nintendo3ds_pdn_set_spi_new();
+
+	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+}
+
+static const char *nintendo3ds_ctr_dt_platform_compat[] __initconst = {
+	"nintendo3ds,ctr",
+	NULL,
+};
+
+DT_MACHINE_START(NINTENDO3DS_DT, "Nintendo 3DS (CTR) (Device Tree)")
+	.init_machine	= nintendo3ds_ctr_dt_init_machine,
+	.dt_compat	= nintendo3ds_ctr_dt_platform_compat,
+MACHINE_END
diff -Naur '--exclude=certs' linux-5.0.3/arch/arm/mach-nintendo3ds/platsmp.c linux-3ds/arch/arm/mach-nintendo3ds/platsmp.c
--- linux-5.0.3/arch/arm/mach-nintendo3ds/platsmp.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/platsmp.c	2019-05-04 18:53:35.937294100 -0300
@@ -0,0 +1,67 @@
+/*
+ * SMP support for the Nintendo 3DS
+ *
+ * Copyright (C) 2016 Sergi Granell
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/memory.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/smp.h>
+
+#include <asm/smp_scu.h>
+
+#include <mach/platsmp.h>
+
+/*
+ * CPU1 waits for IPI Interrupt 0x1,
+ * 0x1FFFFFDC is where it expects the entrypoint.
+ */
+
+#define SECONDARY_STARTUP_ADDR	0x1FFFFFDC
+#define SCU_BASE_ADDR		0x17E00000
+
+extern void smp_cross_call(const struct cpumask *target, unsigned int ipinr);
+
+static int nintendo3ds_smp_boot_secondary(unsigned int cpu,
+				    struct task_struct *idle)
+{
+	//arch_send_wakeup_ipi_mask(cpumask_of(cpu));
+
+	smp_cross_call(cpumask_of(cpu), cpu);
+
+	return 0;
+}
+
+static void nintendo3ds_smp_prepare_cpus(unsigned int max_cpus)
+{
+	void __iomem *scu_base;
+	void __iomem *boot_addr;
+
+	scu_base = ioremap(SCU_BASE_ADDR, SZ_256);
+	scu_enable(scu_base);
+	iounmap(scu_base);
+
+	boot_addr = ioremap((phys_addr_t)SECONDARY_STARTUP_ADDR,
+			       sizeof(phys_addr_t));
+
+	/* Set CPU boot address */
+	writel(virt_to_phys(nintendo3ds_secondary_startup),
+		boot_addr);
+
+	iounmap(boot_addr);
+}
+
+static const struct smp_operations nintendo3ds_smp_ops __initconst = {
+	.smp_prepare_cpus	= nintendo3ds_smp_prepare_cpus,
+	.smp_boot_secondary	= nintendo3ds_smp_boot_secondary,
+};
+CPU_METHOD_OF_DECLARE(nintendo3ds_smp, "nintendo3ds,smp", &nintendo3ds_smp_ops);
diff -Naur '--exclude=certs' linux-5.0.3/copy_3ds.sh linux-3ds/copy_3ds.sh
--- linux-5.0.3/copy_3ds.sh	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/copy_3ds.sh	2019-05-04 18:53:35.938287000 -0300
@@ -0,0 +1,10 @@
+#!/bin/bash
+
+lftp 192.168.1.65:5000 << EOF
+
+put arch/arm/boot/zImage -o /linux/zImage
+put arch/arm/boot/dts/nintendo3ds_ctr.dtb -o /linux/nintendo3ds_ctr.dtb
+put ../arm9linuxfw/arm9linuxfw.bin -o /linux/arm9linuxfw.bin
+
+bye
+EOF
diff -Naur '--exclude=certs' linux-5.0.3/diff_3ds.sh linux-3ds/diff_3ds.sh
--- linux-5.0.3/diff_3ds.sh	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/diff_3ds.sh	2019-05-04 18:53:35.939283100 -0300
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+make clean
+make ARCH=arm clean
+
+rm usr/initramfs_data.cpio.gz
+cp .config arch/arm/configs/nintendo3ds_defconfig
+
+make distclean
+make ARCH=arm distclean
+
+cd ../
+diff -Naur --exclude="certs" linux-5.0.3/ linux-3ds/ > linux-3ds.patch
+cd linux-3ds/
+
+cp arch/arm/configs/nintendo3ds_defconfig .config
diff -Naur '--exclude=certs' linux-5.0.3/drivers/mtd/spi-nor/spi-nor.c linux-3ds/drivers/mtd/spi-nor/spi-nor.c
--- linux-5.0.3/drivers/mtd/spi-nor/spi-nor.c	2019-03-19 09:10:58.000000000 -0300
+++ linux-3ds/drivers/mtd/spi-nor/spi-nor.c	2019-05-08 11:38:57.602923200 -0300
@@ -1938,6 +1938,9 @@
 	{ "m25p64",  INFO(0x202017,  0,  64 * 1024, 128, 0) },
 	{ "m25p128", INFO(0x202018,  0, 256 * 1024,  64, 0) },
 
+	/* HACKED ON TOP FOR NINTENDO 3DS - NEED TO FIND THE CORRECT INFO */
+	{ "m25something", INFO(0x20580C, 0, 64 * 1024, 2, 0)},
+
 	{ "m25p05-nonjedec",  INFO(0, 0,  32 * 1024,   2, 0) },
 	{ "m25p10-nonjedec",  INFO(0, 0,  32 * 1024,   4, 0) },
 	{ "m25p20-nonjedec",  INFO(0, 0,  64 * 1024,   4, 0) },
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/Kconfig linux-3ds/drivers/platform/Kconfig
--- linux-5.0.3/drivers/platform/Kconfig	2019-03-19 09:10:58.000000000 -0300
+++ linux-3ds/drivers/platform/Kconfig	2019-05-04 18:53:35.944280300 -0300
@@ -5,6 +5,10 @@
 source "drivers/platform/mips/Kconfig"
 endif
 
+if ARM
+source "drivers/platform/nintendo3ds/Kconfig"
+endif
+
 source "drivers/platform/goldfish/Kconfig"
 
 source "drivers/platform/chrome/Kconfig"
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/Makefile linux-3ds/drivers/platform/Makefile
--- linux-5.0.3/drivers/platform/Makefile	2019-03-19 09:10:58.000000000 -0300
+++ linux-3ds/drivers/platform/Makefile	2019-05-04 18:53:35.946264800 -0300
@@ -9,3 +9,4 @@
 obj-$(CONFIG_OLPC)		+= olpc/
 obj-$(CONFIG_GOLDFISH)		+= goldfish/
 obj-$(CONFIG_CHROME_PLATFORMS)	+= chrome/
+obj-$(CONFIG_ARCH_NINTENDO3DS)	+= nintendo3ds/
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/Kconfig linux-3ds/drivers/platform/nintendo3ds/Kconfig
--- linux-5.0.3/drivers/platform/nintendo3ds/Kconfig	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/Kconfig	2019-05-11 23:06:08.571854800 -0300
@@ -0,0 +1,136 @@
+#
+# Nintendo 3DS Specific Drivers
+#
+
+menuconfig NINTENDO3DS_PLATFORM_DEVICES
+	bool "Nintendo 3DS specific device drivers"
+	depends on ARCH_NINTENDO3DS
+	default y
+	help
+	  Say Y here to get to use specific device drivers for the Nintendo 3DS
+	  port.
+
+	  It's highly recommended to enable all of them as built-in.
+
+
+if NINTENDO3DS_PLATFORM_DEVICES
+
+config NINTENDO3DS_HID
+	tristate "Nintendo 3DS HID Input Driver"
+	select INPUT_POLLDEV
+	default y
+	help
+	  Say Y here to enable the face buttons and shoulder triggers as buttons.
+
+
+
+config NINTENDO3DS_SPI
+	tristate "Nintendo 3DS SPI"
+	depends on SPI_MASTER
+	default y
+	help
+	  SPI device driver (master).
+
+config NINTENDO3DS_CODEC
+	tristate "Nintendo 3DS CODEC Input Driver"
+	depends on NINTENDO3DS_SPI
+	select INPUT_POLLDEV
+	default y
+	help
+	  Touchscreen and Circle Pad device driver.
+
+
+
+config NINTENDO3DS_PXI
+	tristate "Nintendo 3DS PXI support"
+	default y
+	help
+	  PXI device driver interface (master).
+
+config NINTENDO3DS_MMC
+	tristate "Nintendo 3DS MMC support"
+	depends on NINTENDO3DS_PXI
+	select BLOCK
+	default y
+	help
+	  SD and NAND access device driver.
+
+config NINTENDO3DS_RNG
+	tristate "Nintendo 3DS RNG driver"
+	depends on NINTENDO3DS_PXI
+	select HW_RANDOM
+	default y
+	help
+	  Hardware Random Number Generator driver.
+
+
+config NINTENDO3DS_I2C
+	tristate "Nintendo 3DS I2C bus support"
+	depends on I2C
+	select I2C_ALGOBIT
+	default y
+	help
+	  I2C device driver.
+
+config NINTENDO3DS_MCU
+	tristate "Nintendo 3DS MCU"
+	depends on NINTENDO3DS_I2C
+	select MFD_CORE
+	default y
+	help
+	  Microcontroller interface device driver.
+
+config NINTENDO3DS_RTC
+	tristate "Nintendo 3DS RTC driver"
+	depends on NINTENDO3DS_MCU
+	select RTC_CLASS
+	default y
+	help
+	  Real time clock device driver.
+
+config NINTENDO3DS_LEDS
+	tristate "Nintendo 3DS status LEDs driver"
+	depends on NINTENDO3DS_MCU
+	select NEW_LEDS
+	select LEDS_CLASS
+	default y
+	help
+	  Notification and power LED device driver.
+
+config NINTENDO3DS_RESET
+	tristate "Nintendo 3DS reboot/poweroff driver"
+	depends on NINTENDO3DS_MCU
+	select POWER_RESET
+	default y
+	help
+	  Reboot and poweroff device driver.
+
+config NINTENDO3DS_MCUHID
+	tristate "Nintendo 3DS MCU HID driver"
+	depends on NINTENDO3DS_MCU
+	select INPUT
+	default y
+	help
+	  Driver for extra buttons in the system
+	  (HOME, POWER, Wireless switch and lid state).
+
+config NINTENDO3DS_CHARGER
+	tristate "Nintendo 3DS battery and AC driver"
+	depends on NINTENDO3DS_MCU
+	select POWER_SUPPLY
+	default y
+	help
+	  Battery and AC charger status device driver.
+
+
+
+config NINTENDO3DS_BACKLIGHT
+	tristate "Nintendo 3DS panel backlight driver"
+	select BACKLIGHT_LCD_SUPPORT
+	select LCD_CLASS_DEVICE
+	default y
+	help
+	  LCD panel backlight control device driver.
+
+
+endif # NINTENDO3DS_PLATFORM_DEVICES
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/Makefile linux-3ds/drivers/platform/nintendo3ds/Makefile
--- linux-5.0.3/drivers/platform/nintendo3ds/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/Makefile	2019-05-11 23:04:05.764687600 -0300
@@ -0,0 +1,18 @@
+obj-$(CONFIG_NINTENDO3DS_HID)	+= nintendo3ds_input.o
+
+obj-$(CONFIG_NINTENDO3DS_SPI)	+= nintendo3ds_spi.o
+obj-$(CONFIG_NINTENDO3DS_CODEC)	+= nintendo3ds_codec.o
+
+obj-$(CONFIG_NINTENDO3DS_PXI)	+= nintendo3ds_pxi.o
+obj-$(CONFIG_NINTENDO3DS_MMC)	+= nintendo3ds_mmc.o
+obj-$(CONFIG_NINTENDO3DS_RNG)	+= nintendo3ds_rng.o
+
+obj-$(CONFIG_NINTENDO3DS_I2C)	+= nintendo3ds_i2c.o
+obj-$(CONFIG_NINTENDO3DS_MCU)	+= nintendo3ds_mcu.o
+obj-$(CONFIG_NINTENDO3DS_RTC)	+= nintendo3ds_rtc.o
+obj-$(CONFIG_NINTENDO3DS_LEDS)	+= nintendo3ds_leds.o
+obj-$(CONFIG_NINTENDO3DS_RESET)	+= nintendo3ds_reset.o
+obj-$(CONFIG_NINTENDO3DS_MCUHID)	+= nintendo3ds_mcuhid.o
+obj-$(CONFIG_NINTENDO3DS_CHARGER)	+= nintendo3ds_charger.o
+
+obj-$(CONFIG_NINTENDO3DS_BACKLIGHT)	+= nintendo3ds_backlight.o
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_backlight.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_backlight.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_backlight.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_backlight.c	2019-05-04 18:53:35.951250400 -0300
@@ -0,0 +1,101 @@
+/*
+ *  nintendo3ds_backlight.c
+ *
+ *  Copyright (C) 2018 Wolfvak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/backlight.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-backlight"
+
+/* experimentally determined, could go higher but this is high enough */
+#define N3DS_BL_MAX (192)
+
+static int nintendo3ds_backlight_update_status(struct backlight_device *bd)
+{
+	char __iomem *io = bl_get_data(bd);
+	int intensity = bd->props.brightness;
+
+	iowrite32(intensity, io + 0x240);
+	iowrite32(intensity, io + 0xA40);
+	return 0;
+}
+
+static int nintendo3ds_backlight_get_brightness(struct backlight_device *bd)
+{
+	char __iomem *io = bl_get_data(bd);
+	return ioread32(io + 0x240);
+}
+
+static const struct backlight_ops nintendo3ds_backlight_ops = {
+	.update_status = nintendo3ds_backlight_update_status,
+	.get_brightness = nintendo3ds_backlight_get_brightness,
+};
+
+static int nintendo3ds_backlight_probe(struct platform_device *pdev)
+{
+	char __iomem *iomem;
+	struct resource *mem_res;
+	struct backlight_properties props;
+	struct backlight_device *backlight;
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(mem_res))
+		return PTR_ERR(mem_res);
+
+	iomem = devm_ioremap_resource(&pdev->dev, mem_res);
+	if (IS_ERR(iomem))
+		return PTR_ERR(iomem);
+
+	memset(&props, 0, sizeof(props));
+	props.type = BACKLIGHT_RAW;
+	props.max_brightness = N3DS_BL_MAX;
+	backlight = devm_backlight_device_register(&pdev->dev, DRIVER_NAME,
+					&pdev->dev, iomem, &nintendo3ds_backlight_ops, &props);
+	if (IS_ERR(backlight)) {
+		dev_err(&pdev->dev, "failed to register backlight");
+		return PTR_ERR(backlight);
+	}
+
+	platform_set_drvdata(pdev, backlight);
+	return 0;
+}
+
+static int nintendo3ds_backlight_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_backlight_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{}
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_backlight_of_match);
+
+static struct platform_driver nintendo3ds_backlight_driver = {
+	.probe = nintendo3ds_backlight_probe,
+	.remove = nintendo3ds_backlight_remove,
+
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(nintendo3ds_backlight_of_match),
+	},
+};
+module_platform_driver(nintendo3ds_backlight_driver);
+
+MODULE_AUTHOR("Wolfvak");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Nintendo 3DS backlight driver");
+MODULE_ALIAS("platform:" DRIVER_NAME);
+
+
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_charger.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_charger.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_charger.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_charger.c	2019-05-07 12:38:54.241611700 -0300
@@ -0,0 +1,152 @@
+/*
+ *  nintendo3ds_charger.c
+ *
+ *  Copyright (C) 2018 Wolfvak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/miscdevice.h>
+#include <linux/power_supply.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-charger"
+
+#define CAPACITY_REGISTER 0x0B
+#define CHRGSTAT_REGISTER 0x0F
+
+static int battery_getprop(struct power_supply *psy,
+        enum power_supply_property psp,
+        union power_supply_propval *val)
+{
+    unsigned int batstat, cap;
+    struct regmap *mcu_regmap = power_supply_get_drvdata(psy);
+
+    regmap_read(mcu_regmap, CAPACITY_REGISTER, &cap);
+    regmap_read(mcu_regmap, CHRGSTAT_REGISTER, &batstat);
+
+    switch(psp) {
+        case POWER_SUPPLY_PROP_ONLINE:
+            val->intval = 1;
+            break;
+
+        case POWER_SUPPLY_PROP_STATUS:
+            val->intval = (batstat & 0x10) ?
+                            ((cap >= 99) ? POWER_SUPPLY_STATUS_FULL : POWER_SUPPLY_STATUS_CHARGING)
+                            : POWER_SUPPLY_STATUS_DISCHARGING;
+            break;
+
+        case POWER_SUPPLY_PROP_TECHNOLOGY:
+            val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+            break;
+
+        case POWER_SUPPLY_PROP_CAPACITY:
+            val->intval = cap;
+            break;
+
+        default:
+            return -EINVAL;
+    }
+    return 0;
+}
+
+static int ac_getprop(struct power_supply *psy,
+        enum power_supply_property psp,
+        union power_supply_propval *val)
+{
+    unsigned int acstat;
+    struct regmap *mcu_regmap = power_supply_get_drvdata(psy);
+
+    regmap_read(mcu_regmap, CHRGSTAT_REGISTER, &acstat);
+
+    switch(psp) {
+        case POWER_SUPPLY_PROP_ONLINE:
+            val->intval = (acstat >> 4) & 1;
+            break;
+
+        default:
+            return -EINVAL;
+    }
+    return 0;
+}
+
+static enum power_supply_property battery_properties[] = {
+    POWER_SUPPLY_PROP_STATUS,
+    POWER_SUPPLY_PROP_TECHNOLOGY,
+    POWER_SUPPLY_PROP_CAPACITY,
+};
+static struct power_supply_desc battery_desc = {
+    .name = "battery",
+    .type = POWER_SUPPLY_TYPE_BATTERY,
+    .properties = battery_properties,
+    .num_properties = ARRAY_SIZE(battery_properties),
+    .get_property = battery_getprop,
+};
+
+static enum power_supply_property ac_properties[] = {
+    POWER_SUPPLY_PROP_ONLINE
+};
+static struct power_supply_desc ac_desc = {
+    .name = "ac",
+    .type = POWER_SUPPLY_TYPE_MAINS,
+    .properties = ac_properties,
+    .num_properties = ARRAY_SIZE(ac_properties),
+    .get_property = ac_getprop,
+};
+
+static int nintendo3ds_charger_probe(struct platform_device *pdev)
+{
+    struct power_supply *supply;
+    struct device *dev = &pdev->dev;
+    struct power_supply_config psy_cfg = {};
+
+    psy_cfg.drv_data = dev_get_drvdata(dev->parent);
+
+    supply = devm_power_supply_register(dev, &battery_desc, &psy_cfg);
+    if (IS_ERR(supply)) {
+        dev_warn(dev, "unable to register battery driver");
+        return PTR_ERR(supply);
+    }
+
+    supply = devm_power_supply_register(dev, &ac_desc, &psy_cfg);
+    if (IS_ERR(supply)) {
+        dev_warn(dev, "unable to register AC driver");
+        return PTR_ERR(supply);
+    }
+
+    return 0;
+}
+
+static int nintendo3ds_charger_remove(struct platform_device *pdev)
+{
+    return 0;
+}
+
+static const struct of_device_id nintendo3ds_charger_of_match[] = {
+    { .compatible = "nintendo3ds," DRIVER_NAME, },
+    {}
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_charger_of_match);
+
+static struct platform_driver nintendo3ds_charger_driver = {
+    .probe = nintendo3ds_charger_probe,
+    .remove = nintendo3ds_charger_remove,
+
+    .driver = {
+        .name = DRIVER_NAME,
+        .owner = THIS_MODULE,
+        .of_match_table = of_match_ptr(nintendo3ds_charger_of_match),
+    },
+};
+module_platform_driver(nintendo3ds_charger_driver);
+
+MODULE_AUTHOR("Wolfvak");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Nintendo 3DS battery and AC charger driver");
+MODULE_ALIAS("mfd:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_codec.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_codec.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_codec.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_codec.c	2019-05-04 18:53:35.955240200 -0300
@@ -0,0 +1,548 @@
+/*
+ * nintendo3ds_codec.c
+ *
+ * Copyright (C) 2016 Sergi Granell (xerpi)
+ * Copyright (C) 2017 Paul LaMendola (paulguy)
+ * based on ad7879-spi.c
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/spi/spi.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/jiffies.h>
+
+#include <mach/bottom_lcd.h>
+#include <mach/platform.h>
+
+#define DRIVER_NAME	"nintendo3ds-codec"
+#define POLL_INTERVAL_DEFAULT		20
+#define MAX_12BIT			((1 << 12) - 1)
+#define CIRCLE_PAD_THRESHOLD		150
+#define CIRCLE_PAD_FACTOR		150
+
+#define VKB_ROWS (6)
+#define VKB_COLS (17)
+
+#define HIGHLIGHT_COLOR COLOR_RED
+
+#define LEFT_SHIFTED  BIT(0)
+#define RIGHT_SHIFTED BIT(1)
+
+struct vkb_ctx_t {
+	const struct font_desc *font;
+	unsigned int key_locked[VKB_ROWS][VKB_COLS / sizeof(int) + 1];
+	unsigned int x_offsets[VKB_ROWS][VKB_COLS];
+	unsigned char x_sizes[VKB_ROWS][VKB_COLS];
+	unsigned char last_key;
+	bool locked_key;
+	int held_row;
+	int held_col;
+	char shifted;
+};
+
+struct nintendo3ds_codec_hid {
+	struct spi_device *spi;
+	struct input_polled_dev *polled_dev;
+	struct input_dev *input_dev;
+
+	struct vkb_ctx_t vkb;
+	unsigned long touch_jiffies;
+	bool pendown;
+};
+
+/* VKB stuff */
+
+/*
+0123456789012345678901234567890123456789
+Es 1 2 3 4 5 6 7 8 9 10 11 12 PSc SLk Bk
+` 1 2 3 4 5 6 7 8 9 0 - = BSp Ins Hom PU
+<> q w e r t y u i o p [ ]  \ Del End PD
+Cap a s d f g h j k l ; ' Ent
+LShf z x c v b n m , . / Rshf
+Ctl M Alt Space Alt M Mnu Ctl
+*/
+
+static const char *vkb_map_normal[VKB_ROWS][VKB_COLS] = {
+	{"Es", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "PSc", "SLk", "Bk"},
+	{"`", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=", "BSp", "Ins", "Hom", "PU"},
+	{"<>", "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", " \\", "Del", "End", "PD"},
+	{"Cap", "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'", "Ent", NULL, NULL, NULL, NULL},
+	{"LShf", "z", "x", "c", "v", "b", "n", "m", ",", ".", "/", "RShf", NULL, NULL, NULL, NULL, NULL},
+	{"Ctl", "M", "Alt", "Space", "Alt", "M", "Mnu", "Ctl", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}
+};
+
+static const char *vkb_map_shift[VKB_ROWS][VKB_COLS] = {
+	{"Es", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "PSc", "SLk", "Bk"},
+	{"`", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "_", "+", "BSp", "Ins", "Hom", "PU"},
+	{"<>", "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", "{", "}", " |", "Del", "End", "PD"},
+	{"Cap", "A", "S", "D", "F", "G", "H", "J", "K", "L", ":", "\"", "Ent", NULL, NULL, NULL, NULL},
+	{"LShf", "Z", "X", "C", "V", "B", "N", "M", "<", ">", "?", "RShf", NULL, NULL, NULL, NULL, NULL},
+	{"Ctl", "M", "Alt", "Space", "Alt", "M", "Mnu", "Ctl", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}
+};
+
+static const char vkb_map_keys[VKB_ROWS][VKB_COLS] = {
+	{KEY_ESC, KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11, KEY_F12, KEY_SYSRQ, KEY_SCROLLLOCK, KEY_PAUSE},
+	{KEY_GRAVE, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_0, KEY_MINUS, KEY_EQUAL, KEY_BACKSPACE, KEY_INSERT, KEY_HOME, KEY_PAGEUP},
+	{KEY_TAB, KEY_Q, KEY_W, KEY_E, KEY_R, KEY_T, KEY_Y, KEY_U, KEY_I, KEY_O, KEY_P, KEY_LEFTBRACE, KEY_RIGHTBRACE, KEY_BACKSLASH, KEY_DELETE, KEY_END, KEY_PAGEDOWN},
+	{KEY_CAPSLOCK, KEY_A, KEY_S, KEY_D, KEY_F, KEY_G, KEY_H, KEY_J, KEY_K, KEY_L, KEY_SEMICOLON, KEY_COMMA, KEY_ENTER, 0, 0, 0, 0},
+	{KEY_LEFTSHIFT, KEY_Z, KEY_X, KEY_C, KEY_V, KEY_B, KEY_N, KEY_M, KEY_COMMA, KEY_DOT, KEY_SLASH, KEY_RIGHTSHIFT, 0, 0, 0, 0, 0},
+	{KEY_LEFTCTRL, KEY_LEFTMETA, KEY_LEFTALT, KEY_SPACE, KEY_RIGHTALT, KEY_RIGHTMETA, KEY_MENU, KEY_RIGHTCTRL, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+};
+
+static void vkb_draw_key(const struct vkb_ctx_t *vkb, int row, int col) {
+	unsigned int color;
+
+	if(vkb->key_locked[row][col / sizeof(int)] & BIT(col % sizeof(int)))
+		color = HIGHLIGHT_COLOR;
+	else
+		color = COLOR_WHITE;
+
+	if(vkb->shifted) {
+		if(vkb_map_shift[row][col]) {
+			if (row == 0 || row == 5 || vkb_map_normal[row][col][1] != '\0')
+				nintendo3ds_bottom_lcd_draw_text(vkb->font, vkb->x_offsets[row][col], row * vkb->font->height * 2, COLOR_BLACK, color,
+						                               vkb_map_shift[row][col]);
+			else
+				nintendo3ds_bottom_lcd_draw_text(vkb->font, vkb->x_offsets[row][col], row * vkb->font->height * 2, color, COLOR_BLACK, 
+						                               vkb_map_shift[row][col]);
+		}
+	} else {
+		if(vkb_map_normal[row][col]) {
+			if (row == 0 || row == 5 || vkb_map_normal[row][col][1] != '\0')
+				nintendo3ds_bottom_lcd_draw_text(vkb->font, vkb->x_offsets[row][col], row * vkb->font->height * 2, COLOR_BLACK, color,
+						                               vkb_map_normal[row][col]);
+			else
+				nintendo3ds_bottom_lcd_draw_text(vkb->font, vkb->x_offsets[row][col], row * vkb->font->height * 2, color, COLOR_BLACK, 
+						                               vkb_map_normal[row][col]);
+		}
+	}
+}
+
+static void vkb_draw_bottom_lcd(const struct vkb_ctx_t *vkb)
+{
+	int i, j;
+
+	for (j = 0; j < VKB_ROWS; j++) {
+		for (i = 0; i < VKB_COLS; i++) {
+			vkb_draw_key(vkb, j, i);
+		}
+	}
+}
+
+static int vkb_init(struct vkb_ctx_t *vkb)
+{
+	int x, i, j;
+
+	vkb->font = get_default_font(NINTENDO3DS_LCD_BOT_WIDTH, NINTENDO3DS_LCD_BOT_HEIGHT, -1, -1);
+	vkb->last_key = 0;
+	vkb->locked_key = false;
+	vkb->shifted = false;
+
+	for(j = 0; j < VKB_ROWS; j++) {
+		x = 0;
+		for(i = 0; i < VKB_COLS; i++) {
+			if (!vkb_map_normal[j][i]) {
+				vkb->x_sizes[j][i] = 0;
+				vkb->x_offsets[j][i] = 0;
+				continue;
+			}
+			vkb->x_offsets[j][i] = x;
+			vkb->x_sizes[j][i] = (strlen(vkb_map_normal[j][i]) + 1) * vkb->font->width;
+			x += vkb->x_sizes[j][i];
+		}
+	}
+
+	for(j = 0; j < VKB_ROWS; j++) {
+		for(i = 0; i < VKB_COLS / sizeof(int) + 1; i++) {
+			vkb->key_locked[j][i] = 0;
+		}
+	}
+
+	nintendo3ds_bottom_lcd_clear_screen(COLOR_BLACK);
+	vkb_draw_bottom_lcd(vkb);
+
+	return 0;
+}
+/* End VKB stuff */
+
+/* SPI stuff */
+static int spi_write_2(struct spi_device *spi,
+		       u8 *tx_buf0, u8 tx_len0,
+		       u8 *tx_buf1, u8 tx_len1)
+{
+	struct spi_message msg;
+	struct spi_transfer xfers[2];
+
+	memset(xfers, 0, sizeof(xfers));
+
+	xfers[0].tx_buf = tx_buf0;
+	xfers[0].len = tx_len0;
+
+	xfers[1].tx_buf = tx_buf1;
+	xfers[1].len = tx_len1;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	return spi_sync(spi, &msg);
+}
+
+static int spi_write_read(struct spi_device *spi,
+			  u8 *tx_buf, u8 tx_len,
+			  u8 *rx_buf, u8 rx_len)
+{
+	struct spi_message msg;
+	struct spi_transfer xfers[2];
+
+	memset(xfers, 0, sizeof(xfers));
+
+	xfers[0].tx_buf = tx_buf;
+	xfers[0].len = tx_len;
+
+	xfers[1].rx_buf = rx_buf;
+	xfers[1].len = rx_len;
+
+	spi_message_init(&msg);
+
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	return spi_sync(spi, &msg);
+}
+
+static void spi_reg_select(struct spi_device *spi, u8 reg)
+{
+	u8 buffer1[4];
+	u8 buffer2[0x40];
+
+	buffer1[0] = 0;
+	buffer2[0] = reg;
+
+	spi_write_2(spi, buffer1, 1, buffer2, 1);
+}
+
+static u8 spi_reg_read_offset(struct spi_device *spi, u8 offset)
+{
+	u8 buffer_wr[8];
+	u8 buffer_rd[0x40];
+
+	buffer_wr[0] = 1 | (offset << 1);
+
+	spi_write_read(spi, buffer_wr, 1, buffer_rd, 1);
+
+	return buffer_rd[0];
+}
+
+static void spi_reg_write_offset(struct spi_device *spi, u8 reg, u8 val)
+{
+	u8 buffer1[8];
+	u8 buffer2[0x40];
+
+	buffer1[0] = (reg << 1); // Write
+	buffer2[0] = val;
+
+	spi_write_2(spi, buffer1, 1, buffer2, 1);
+}
+
+static void spi_reg_read_buffer(struct spi_device *spi,
+			       u8 offset, void *buffer, u8 size)
+{
+	u8 buffer_wr[0x10];
+
+	buffer_wr[0] = 1 | (offset << 1);
+
+	spi_write_read(spi, buffer_wr, 1, buffer, size);
+}
+
+static void spi_reg_mask_offset(struct spi_device *spi, u8 offset, u8 mask0, u8 mask1)
+{
+	u8 buffer1[4];
+	u8 buffer2[0x40];
+
+	buffer1[0] = 1 | (offset << 1);
+
+	spi_write_read(spi, buffer1, 1, buffer2, 1);
+
+	buffer1[0] = offset << 1;
+	buffer2[0] = (buffer2[0] & ~mask1) | (mask0 & mask1);
+
+	spi_write_2(spi, buffer1, 1, buffer2, 1);
+}
+
+static void spi_codec_hid_initialize(struct spi_device *spi)
+{
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x24, 0x98);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x26, 0x00);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x25, 0x43);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x24, 0x18);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x17, 0x43);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x19, 0x69);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x1B, 0x80);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x27, 0x11);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x26, 0xEC);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x24, 0x18);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x25, 0x53);
+
+	spi_reg_select(spi, 0x67);
+	spi_reg_mask_offset(spi, 0x26, 0x80, 0x80);
+	spi_reg_select(spi, 0x67);
+	spi_reg_mask_offset(spi, 0x24, 0x00, 0x80);
+	spi_reg_select(spi, 0x67);
+	spi_reg_mask_offset(spi, 0x25, 0x10, 0x3C);
+}
+
+static void spi_codec_hid_request_data(struct spi_device *spi, u8 *buffer)
+{
+	spi_reg_select(spi, 0x67);
+	spi_reg_read_offset(spi, 0x26);
+	spi_reg_select(spi, 0xFB);
+	spi_reg_read_buffer(spi, 1, buffer, 0x34);
+}
+/* End SPI stuff */
+
+static void nintendo3ds_codec_hid_open(struct input_polled_dev *dev)
+{
+}
+
+static void nintendo3ds_codec_hid_close(struct input_polled_dev *dev)
+{
+}
+
+static void nintendo3ds_codec_hid_poll(struct input_polled_dev *polled_dev)
+{
+	struct nintendo3ds_codec_hid *codec_hid = polled_dev->private;
+	struct input_dev *input_dev = codec_hid->input_dev;
+	struct vkb_ctx_t *vkb = &codec_hid->vkb;
+
+	u8 raw_data[0x40] __attribute__((aligned(sizeof(u16))));
+	bool pendown;
+	u16 raw_touch_x;
+	u16 raw_touch_y;
+	u16 screen_touch_x;
+	u16 screen_touch_y;
+	s16 raw_circlepad_x;
+	s16 raw_circlepad_y;
+	bool sync = false;
+	int i, j;
+
+	spi_codec_hid_request_data(codec_hid->spi, raw_data);
+
+	raw_circlepad_x =
+		(s16)le16_to_cpu(((raw_data[0x24] << 8) | raw_data[0x25]) & 0xFFF) - 2048;
+	raw_circlepad_y =
+		(s16)le16_to_cpu(((raw_data[0x14] << 8) | raw_data[0x15]) & 0xFFF) - 2048;
+
+	if (abs(raw_circlepad_x) > CIRCLE_PAD_THRESHOLD) {
+		input_report_rel(input_dev, REL_X,
+				 -raw_circlepad_x / CIRCLE_PAD_FACTOR);
+		sync = true;
+	}
+
+	if (abs(raw_circlepad_y) > CIRCLE_PAD_THRESHOLD) {
+		input_report_rel(input_dev, REL_Y,
+				 -raw_circlepad_y / CIRCLE_PAD_FACTOR);
+		sync = true;
+	}
+
+	pendown = !(raw_data[0] & BIT(4));
+
+	if (pendown) {
+		if(!codec_hid->pendown) {
+			raw_touch_x = le16_to_cpu((raw_data[0]  << 8) | raw_data[1]);
+			raw_touch_y = le16_to_cpu((raw_data[10] << 8) | raw_data[11]);
+
+			screen_touch_x = (u16)((u32)raw_touch_x * NINTENDO3DS_LCD_BOT_WIDTH / MAX_12BIT);
+			screen_touch_y = (u16)((u32)raw_touch_y * NINTENDO3DS_LCD_BOT_HEIGHT / MAX_12BIT);
+
+			for(j = 0; j < VKB_ROWS; j++) {
+				for(i = 0; i < VKB_COLS; i++) {
+					if(vkb->x_sizes[j][i] > 0 &&
+					   screen_touch_x >= vkb->x_offsets[j][i] &&
+					   screen_touch_x < vkb->x_offsets[j][i] + vkb->x_sizes[j][i] &&
+					   screen_touch_y >= j * vkb->font->height * 2 &&
+					   screen_touch_y < (j + 1) * vkb->font->height * 2) {
+						codec_hid->pendown = true;
+
+						codec_hid->touch_jiffies = jiffies;
+
+						vkb->last_key = vkb_map_keys[j][i];
+						if(vkb->key_locked[j][i / sizeof(int)] & BIT(i % sizeof(int))) {
+							vkb->key_locked[j][i / sizeof(int)] &= ~BIT(i % sizeof(int));
+							input_report_key(input_dev, vkb->last_key, 0);
+							if(vkb->last_key == KEY_LEFTSHIFT)
+								vkb->shifted &= ~LEFT_SHIFTED;
+							else if(vkb->last_key == KEY_RIGHTSHIFT)
+								vkb->shifted &= ~RIGHT_SHIFTED;
+
+							if(vkb->shifted == 0)
+								vkb_draw_bottom_lcd(vkb);
+
+							vkb->locked_key = true;
+
+							vkb_draw_key(vkb, j, i);
+						} else {
+							input_report_key(input_dev, vkb->last_key, 1);
+						}
+
+						vkb->held_row = j;
+						vkb->held_col = i;
+
+						sync = true;
+						i = VKB_COLS;
+						j = VKB_ROWS;
+					}
+				}
+			}
+		} else {
+			if(!vkb->locked_key && time_is_before_jiffies(codec_hid->touch_jiffies + msecs_to_jiffies(500))) {
+				vkb->key_locked[vkb->held_row][vkb->held_col / sizeof(int)] |= BIT(vkb->held_col % sizeof(int));
+				vkb->locked_key = true;
+
+				if(vkb_map_keys[vkb->held_row][vkb->held_col] == KEY_LEFTSHIFT)
+					vkb->shifted |= LEFT_SHIFTED;
+				else if(vkb_map_keys[vkb->held_row][vkb->held_col] == KEY_RIGHTSHIFT)
+					vkb->shifted |= RIGHT_SHIFTED;
+
+				if(vkb->shifted != 0)
+					vkb_draw_bottom_lcd(vkb);
+
+				vkb_draw_key(vkb, vkb->held_row, vkb->held_col);
+			}
+		}
+	} else {
+		codec_hid->pendown = false;
+
+		if(vkb->locked_key) {
+			vkb->locked_key = false;
+		} else {
+			if(vkb->last_key) {
+				input_report_key(input_dev, vkb->last_key, 0);
+				sync = true;
+			}
+		}
+
+		vkb->last_key = 0;
+	}
+
+	if(sync)
+		input_sync(input_dev);
+}
+
+static int nintendo3ds_codec_hid_probe(struct spi_device *spi)
+{
+	struct nintendo3ds_codec_hid *codec_hid;
+	struct input_polled_dev *polled_dev;
+	struct input_dev *input_dev;
+	int err;
+	int i, j;
+
+	/* SPI circle pad and touchscreen stuff */
+	spi->bits_per_word = 8;
+	spi->mode = SPI_MODE_0;
+
+	err = spi_setup(spi);
+	if (err < 0) {
+		dev_err(&spi->dev, "spi setup error (%d)", err);
+		return err;
+	}
+
+	codec_hid = devm_kzalloc(&spi->dev, sizeof(*codec_hid), GFP_KERNEL);
+	if (IS_ERR(codec_hid)) {
+		dev_err(&spi->dev, "failed to allocate driver (%lu)", PTR_ERR(codec_hid));
+		return PTR_ERR(codec_hid);
+	}
+
+	polled_dev = devm_input_allocate_polled_device(&spi->dev);
+	if (IS_ERR(polled_dev)) {
+		dev_err(&spi->dev, "failed to allocate input device (%d)", err);
+		return PTR_ERR(polled_dev);
+	}
+
+	polled_dev->private = codec_hid;
+	polled_dev->poll = nintendo3ds_codec_hid_poll;
+	polled_dev->open = nintendo3ds_codec_hid_open;
+	polled_dev->close = nintendo3ds_codec_hid_close;
+	polled_dev->poll_interval = POLL_INTERVAL_DEFAULT;
+
+	input_dev = polled_dev->input;
+	input_dev->name = "Nintendo 3DS CODEC HID";
+	input_dev->phys = DRIVER_NAME "/input0";
+	input_dev->id.bustype = BUS_SPI;
+	input_dev->dev.parent = &spi->dev;
+
+	/* circle pad/mouse stuff */
+	set_bit(EV_REL, input_dev->evbit);
+	set_bit(REL_X, input_dev->relbit);
+	set_bit(REL_Y, input_dev->relbit);
+	set_bit(REL_WHEEL, input_dev->relbit);
+
+	/* Enable VKB keys */
+	set_bit(EV_KEY, input_dev->evbit);
+
+	for (i = 0; i < VKB_ROWS; i++) {
+		for (j = 0; j < VKB_COLS; j++) {
+			if (vkb_map_keys[i][j])
+				set_bit(vkb_map_keys[i][j], input_dev->keybit);
+		}
+	}
+
+	/* dunno what this does but the other driver sets this */
+	input_set_capability(input_dev, EV_MSC, MSC_SCAN);
+
+	codec_hid->spi = spi;
+	codec_hid->polled_dev = polled_dev;
+	codec_hid->input_dev = polled_dev->input;
+	vkb_init(&codec_hid->vkb);
+	spi_set_drvdata(spi, codec_hid);
+
+	spi_codec_hid_initialize(spi);
+
+	err = input_register_polled_device(polled_dev);
+	if (err < 0) {
+		dev_err(&spi->dev, "failed to register input device (%d)", err);
+		return err;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id nintendo3ds_codec_hid_dt_ids[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_codec_hid_dt_ids);
+#endif
+
+static struct spi_driver nintendo3ds_codec_hid_driver = {
+	.probe = nintendo3ds_codec_hid_probe,
+
+	.driver = {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table	= of_match_ptr(nintendo3ds_codec_hid_dt_ids),
+	},
+};
+module_spi_driver(nintendo3ds_codec_hid_driver);
+
+MODULE_AUTHOR("Sergi Granell <xerpi.g.12@gmail.com>");
+MODULE_DESCRIPTION("Nintendo 3DS CODEC HID driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("spi:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_i2c.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_i2c.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_i2c.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_i2c.c	2019-05-11 12:11:12.073410700 -0300
@@ -0,0 +1,242 @@
+/*
+ *  nintendo3ds_i2c.c
+ *
+ *  Copyright (C) 2016 Sergi Granell
+ *  based on i2c-versatile.c and i2c-exynos5.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-i2c"
+
+/* I2C Registers */
+#define I2C_REG_DATA_OFF	0x00
+#define I2C_REG_CNT_OFF		0x01
+#define I2C_REG_CNTEX_OFF	0x02
+#define I2C_REG_SCL_OFF		0x04
+
+/* CNT Register bits */
+#define I2C_CNT_STOP	(1 << 0)
+#define I2C_CNT_START	(1 << 1)
+#define I2C_CNT_PAUSE	(1 << 2)
+#define I2C_CNT_ACK		(1 << 4)
+#define I2C_CNT_DATADIR	(1 << 5)
+#define I2C_CNT_INTEN	(1 << 6)
+#define I2C_CNT_STAT	(1 << 7)
+
+/* CNT Register data direction bit */
+#define I2C_CNT_DATADIR_WR (0 << 5)
+#define I2C_CNT_DATADIR_RD (1 << 5)
+
+/* CNT Register stat bit */
+#define I2C_CNT_STAT_START (1 << 7)
+#define I2C_CNT_STAT_BUSY  (1 << 7)
+
+#define I2C_SET_DATA_REG(base,val)	(writeb(val, base + I2C_REG_DATA_OFF))
+#define I2C_GET_DATA_REG(base)		(readb(base + I2C_REG_DATA_OFF))
+#define I2C_SET_CNT_REG(base,val)	(writeb(val, base + I2C_REG_CNT_OFF))
+#define I2C_GET_CNT_REG(base)		(readb(base + I2C_REG_CNT_OFF))
+#define I2C_SET_CNTEX_REG(base,val)	(writew(val, base + I2C_REG_CNTEX_OFF))
+#define I2C_GET_CNTEX_REG(base)		(readw(base + I2C_REG_CNTEX_OFF))
+#define I2C_SET_SCL_REG(base,val)	(writew(val, base + I2C_REG_SCL_OFF))
+#define I2C_GET_SCL_REG(base)		(readw(base + I2C_REG_SCL_OFF))
+#define I2C_BUS_IS_BUSY(base)		(I2C_GET_CNT_REG(base) & I2C_CNT_STAT_BUSY)
+
+
+struct nintendo3ds_i2c {
+	unsigned irq;
+	void __iomem *base;
+	struct i2c_adapter adap;
+};
+
+static inline void i2c_wait_busy(void __iomem *base)
+{
+	while (I2C_BUS_IS_BUSY(base))
+		;
+}
+
+static inline void i2c_select_device(void __iomem *base, u8 addr)
+{
+	i2c_wait_busy(base);
+	I2C_SET_DATA_REG(base, addr);
+	I2C_SET_CNT_REG(base, I2C_CNT_STAT_START | I2C_CNT_START);
+}
+
+static inline void i2c_select_register(void __iomem *base, u8 reg)
+{
+	i2c_wait_busy(base);
+	I2C_SET_DATA_REG(base, reg);
+	I2C_SET_CNT_REG(base, I2C_CNT_STAT_START);
+}
+
+static int nintendo3ds_i2c_xfer_msg(struct nintendo3ds_i2c *i2c,
+			struct i2c_msg *msg, bool first)
+{
+	void __iomem *base = i2c->base;
+	int i;
+
+	if (msg->len == 1 && first) {
+		/* Only select device register */
+		i2c_select_device(base, msg->addr & 0xFF);
+		i2c_select_register(base, msg->buf[0]);
+	} else if (msg->flags & I2C_M_RD) {
+		i2c_select_device(base, (msg->addr & 0xFF) | 1);
+
+		for (i = 0; i < msg->len - 1; i++) {
+			i2c_wait_busy(base);
+			I2C_SET_CNT_REG(base, I2C_CNT_STAT_START
+				| I2C_CNT_INTEN | I2C_CNT_DATADIR_RD | I2C_CNT_ACK);
+			i2c_wait_busy(base);
+			msg->buf[i] = I2C_GET_DATA_REG(base);
+		}
+		/* Last byte */
+		i2c_wait_busy(base);
+		I2C_SET_CNT_REG(base, I2C_CNT_STOP | I2C_CNT_STAT_START
+			| I2C_CNT_INTEN | I2C_CNT_DATADIR_RD);
+		i2c_wait_busy(base);
+		msg->buf[i] = I2C_GET_DATA_REG(base);
+	} else {
+		for (i = 0; i < msg->len - 1; i++) {
+			i2c_wait_busy(base);
+			I2C_SET_DATA_REG(base, msg->buf[i]);
+			i2c_wait_busy(base);
+			I2C_SET_CNT_REG(base, I2C_CNT_STAT_START
+				| I2C_CNT_INTEN | I2C_CNT_DATADIR_WR);
+		}
+		/* Last byte */
+		i2c_wait_busy(base);
+		I2C_SET_DATA_REG(base, msg->buf[i]);
+		i2c_wait_busy(base);
+		I2C_SET_CNT_REG(base, I2C_CNT_STOP | I2C_CNT_STAT_START
+			| I2C_CNT_INTEN | I2C_CNT_DATADIR_WR);
+	}
+
+	return 0;
+}
+
+static int nintendo3ds_i2c_master_xfer(struct i2c_adapter *adap,
+			struct i2c_msg *msgs, int num)
+{
+	struct nintendo3ds_i2c *i2c = adap->algo_data;
+	int i, ret = 0;
+
+	if (num == 1 && msgs[0].len > 1) {
+		// HACK - needs to be fixed
+		struct i2c_msg xfer[2];
+		xfer[0].addr = msgs->addr;
+		xfer[0].flags = 0;
+		xfer[0].len = 1;
+		xfer[0].buf = msgs->buf;
+
+		xfer[1].addr = msgs->addr;
+		xfer[1].flags = msgs->flags;
+		xfer[1].len = msgs->len - 1;
+		xfer[1].buf = (u8*)msgs->buf + 1;
+
+		return nintendo3ds_i2c_master_xfer(adap, xfer, 2);
+	}
+
+	for (i = 0; i < num; i++, msgs++) {
+		ret = nintendo3ds_i2c_xfer_msg(i2c, msgs, (i == 0));
+		if (ret < 0)
+			return ret;
+	}
+
+	return i;
+}
+
+static u32 nintendo3ds_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C;
+}
+
+static const struct i2c_algorithm nintendo3ds_i2c_algo = {
+	.master_xfer	= nintendo3ds_i2c_master_xfer,
+	.functionality	= nintendo3ds_i2c_func,
+};
+
+static int nintendo3ds_i2c_probe(struct platform_device *pdev)
+{
+	struct nintendo3ds_i2c *i2c;
+	struct resource *mem;
+	int ret;
+
+	i2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);
+	if (IS_ERR(i2c))
+		return PTR_ERR(i2c);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(mem))
+		return PTR_ERR(mem);
+
+	i2c->base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(i2c->base))
+		return PTR_ERR(i2c->base);
+
+	//i2c->irq = platform_get_irq(pdev, 0);
+	//if (!i2c->irq)
+	//	return -EINVAL;
+
+	/* hardware reset */
+	I2C_SET_CNT_REG(i2c->base, 0);
+	I2C_SET_CNTEX_REG(i2c->base, 2);
+	I2C_SET_SCL_REG(i2c->base, 1280);
+	i2c_wait_busy(i2c->base);
+
+	/* Setup the i2c_adapter */
+	i2c->adap.owner		= THIS_MODULE;
+	strlcpy(i2c->adap.name, "Nintendo 3DS I2C adapter",
+		sizeof(i2c->adap.name));
+	i2c->adap.dev.parent 	= &pdev->dev;
+	i2c->adap.dev.of_node	= pdev->dev.of_node;
+	i2c->adap.algo		= &nintendo3ds_i2c_algo;
+	i2c->adap.algo_data	= i2c;
+
+	platform_set_drvdata(pdev, i2c);
+
+	ret = i2c_add_adapter(&i2c->adap);
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static int nintendo3ds_i2c_remove(struct platform_device *pdev)
+{
+	struct nintendo3ds_i2c *i2c = platform_get_drvdata(pdev);
+	i2c_del_adapter(&i2c->adap);
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_i2c_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_i2c_of_match);
+
+static struct platform_driver nintendo3ds_i2c_driver = {
+	.probe		= nintendo3ds_i2c_probe,
+	.remove		= nintendo3ds_i2c_remove,
+
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(nintendo3ds_i2c_of_match),
+	},
+};
+
+module_platform_driver(nintendo3ds_i2c_driver);
+
+MODULE_DESCRIPTION("Nintendo 3DS I2C bus driver");
+MODULE_AUTHOR("Sergi Granell, <xerpi.g.12@gmail.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_input.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_input.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_input.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_input.c	2019-05-04 18:53:35.964231000 -0300
@@ -0,0 +1,189 @@
+/*
+ *  nintendo3ds_input.c
+ *
+ *  Copyright (C) 2015 Sergi Granell
+ *  Copyright (C) 2017 Paul LaMendola
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <asm/io.h>
+
+#include <mach/platform.h>
+
+#define DRIVER_NAME "nintendo3ds-input"
+
+/***** Buttons *****/
+
+/* We poll keys - msecs */
+#define POLL_INTERVAL_DEFAULT	20
+
+#define BUTTON_A      (1 << 0)
+#define BUTTON_B      (1 << 1)
+#define BUTTON_SELECT (1 << 2)
+#define BUTTON_START  (1 << 3)
+#define BUTTON_RIGHT  (1 << 4)
+#define BUTTON_LEFT   (1 << 5)
+#define BUTTON_UP     (1 << 6)
+#define BUTTON_DOWN   (1 << 7)
+#define BUTTON_R1     (1 << 8)
+#define BUTTON_L1     (1 << 9)
+#define BUTTON_X      (1 << 10)
+#define BUTTON_Y      (1 << 11)
+
+#define BUTTON_HELD(b, m) (~(b) & (m))
+#define BUTTON_PRESSED(b, o, m) ((~(b) & (o)) & (m))
+#define BUTTON_CHANGED(b, o, m) (((b) ^ (o)) & (m))
+
+struct nintendo3ds_input_dev {
+	struct input_polled_dev *polldev;
+	void __iomem *hid_input;
+	unsigned int old_buttons;
+};
+
+static const struct {
+	unsigned int in, out;
+} button_map[] = {
+	{BUTTON_A, BTN_A},
+	{BUTTON_B, BTN_B},
+	{BUTTON_X, BTN_X},
+	{BUTTON_Y, BTN_Y},
+	{BUTTON_L1, BTN_TL},
+	{BUTTON_R1, BTN_TR},
+	{BUTTON_START, BTN_START},
+	{BUTTON_UP, KEY_UP},
+	{BUTTON_DOWN, KEY_DOWN},
+	{BUTTON_LEFT, KEY_LEFT},
+	{BUTTON_RIGHT, KEY_RIGHT},
+};
+
+#define CHECK_BUTTON(inbutton, outbutton) \
+	if (BUTTON_CHANGED(buttons, old_buttons, inbutton)) \
+		input_report_key(idev, outbutton, BUTTON_HELD(buttons, inbutton));
+
+static void nintendo3ds_input_poll(struct input_polled_dev *pdev)
+{
+	struct nintendo3ds_input_dev *n3ds_input_dev = pdev->private;
+	struct input_dev *idev = pdev->input;
+	unsigned int buttons;
+	unsigned int old_buttons;
+	int i;
+
+	buttons = ioread32(n3ds_input_dev->hid_input);
+
+	old_buttons = n3ds_input_dev->old_buttons;
+
+	for(i = 0; i < ARRAY_SIZE(button_map); i++)
+		CHECK_BUTTON(button_map[i].in, button_map[i].out)
+
+	if(buttons != n3ds_input_dev->old_buttons) {
+		input_sync(idev);
+	}
+
+	n3ds_input_dev->old_buttons = buttons;
+}
+
+static int nintendo3ds_input_probe(struct platform_device *pdev)
+{
+	struct nintendo3ds_input_dev *n3ds_input_dev;
+	struct input_polled_dev *polldev;
+	struct input_dev *idev;
+	void __iomem *hidregs;
+	struct resource *mem;
+	int i, err;
+
+	n3ds_input_dev = devm_kzalloc(&pdev->dev, sizeof(*n3ds_input_dev), GFP_KERNEL);
+	if (IS_ERR(n3ds_input_dev)) {
+		dev_err(&pdev->dev, "failed to allocate driver");
+		return PTR_ERR(n3ds_input_dev);
+	}
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(mem)) {
+		dev_err(&pdev->dev, "failed to get memory resource");
+		return PTR_ERR(mem);
+	}
+
+	hidregs = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(hidregs)) {
+		dev_err(&pdev->dev, "failed to map registers");
+		return PTR_ERR(hidregs);
+	}
+
+	polldev = input_allocate_polled_device();
+	if (IS_ERR(polldev)) {
+		dev_err(&pdev->dev, "failed to allocate input device");
+		return PTR_ERR(polldev);
+	}
+
+	polldev->poll = nintendo3ds_input_poll;
+	polldev->poll_interval = POLL_INTERVAL_DEFAULT;
+	polldev->private = n3ds_input_dev;
+
+	idev = polldev->input;
+	idev->name = "Nintendo 3DS input";
+	idev->phys = "nintendo3ds/input0";
+	idev->id.bustype = BUS_HOST;
+	idev->dev.parent = &pdev->dev;
+
+	set_bit(EV_KEY, idev->evbit);
+	for(i = 0; i < ARRAY_SIZE(button_map); i++)
+		set_bit(button_map[i].out, idev->keybit);
+
+	input_set_capability(idev, EV_MSC, MSC_SCAN);
+
+	n3ds_input_dev->polldev = polldev;
+	n3ds_input_dev->hid_input = hidregs;
+
+	err = input_register_polled_device(polldev);
+	if (err < 0) {
+		dev_err(&pdev->dev, "failed to register device (%d)", err);
+		input_free_polled_device(polldev);
+		return err;
+	}
+
+	return 0;
+}
+
+static int nintendo3ds_input_remove(struct platform_device *pdev)
+{
+	struct nintendo3ds_input_dev *dev = platform_get_drvdata(pdev);
+
+	input_unregister_polled_device(dev->polldev);
+	input_free_polled_device(dev->polldev);
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_input_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_input_of_match);
+
+static struct platform_driver nintendo3ds_input_driver = {
+	.probe	= nintendo3ds_input_probe,
+	.remove	= nintendo3ds_input_remove,
+
+	.driver	= {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = nintendo3ds_input_of_match,
+	},
+};
+
+module_platform_driver(nintendo3ds_input_driver);
+
+MODULE_DESCRIPTION("Nintendo 3DS input driver");
+MODULE_AUTHOR("Sergi Granell, <xerpi.g.12@gmail.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_leds.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_leds.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_leds.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_leds.c	2019-05-09 19:32:55.783254800 -0300
@@ -0,0 +1,143 @@
+/*
+ * nintendo3ds_led.c
+ *
+ * Copyright (C) 2018 Wolfvak
+ * Information gathered from http://3dbrew.org/wiki/MCURTC:SetInfoLEDPattern
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/init.h>
+#include <linux/leds.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-leds"
+
+#define INFOLED_REGISTER	0x2D
+
+struct nintendo3ds_led_regstate {
+	u8 delay;
+	u8 smoothing;
+	u8 loop_delay;
+	u8 unknown;
+
+	u8 color[3][32];
+} __attribute__((packed));
+
+/*
+ * ugly containerization hack is ugly, because
+ * LED devices dont get any private data to use
+ */
+struct nintendo3ds_led_cont {
+	unsigned int id;
+	struct led_classdev led;
+};
+
+struct nintendo3ds_leds {
+	struct regmap *mcu_regmap;
+	struct nintendo3ds_led_cont cont[3];
+	struct nintendo3ds_led_regstate led_regstate;
+};
+
+static const char *nintendo3ds_led_colors[] = {
+	"nintendo3ds:red:status",
+	"nintendo3ds:green:status",
+	"nintendo3ds:blue:status",
+};
+
+/*
+ * Whenever there's a proper interface for programmable RGB LEDs, I'll update
+ * the code to reflect this, since the LED interface on the 3DS is flexible.
+ *
+ * Right now, it'll remain as three static LEDs that get mixed together.
+ */
+static int nintendo3ds_leds_setbrightness(struct led_classdev *led_cdev,
+												enum led_brightness brightness)
+{
+	int i, led_id;
+	struct regmap *mcu_regmap;
+	struct nintendo3ds_leds *leds;
+	struct nintendo3ds_led_cont *cont;
+	struct nintendo3ds_led_regstate *regs;
+
+	cont = container_of(led_cdev, struct nintendo3ds_led_cont, led);
+
+	led_id = cont->id;
+	if (led_id > 3)
+		return -EINVAL;
+
+	leds = container_of(cont, struct nintendo3ds_leds, cont[led_id]);
+	regs = &leds->led_regstate;
+	mcu_regmap = leds->mcu_regmap;
+
+	brightness = (brightness == LED_ON) ? LED_FULL : brightness;
+	for (i = 0; i < 32; i++)
+		regs->color[led_id][i] = brightness;
+
+	regmap_raw_write(mcu_regmap, INFOLED_REGISTER, regs, sizeof(*regs));
+	return 0;
+}
+
+static int nintendo3ds_infoled_probe(struct platform_device *pdev)
+{
+	int i, res;
+	struct nintendo3ds_leds *leds;
+
+	leds = devm_kzalloc(&pdev->dev, sizeof(*leds), GFP_KERNEL);
+	if (IS_ERR(leds)) {
+		dev_err(&pdev->dev, "failed to allocate driver");
+		return PTR_ERR(leds);
+	}
+
+	/* set up LEDs structure information */
+	leds->mcu_regmap = dev_get_drvdata(pdev->dev.parent);
+
+	/* set up LED class devices */
+	for (i = 0; i < 3; i++) {
+		struct nintendo3ds_led_cont *cont;
+		struct led_classdev *led;
+
+		cont = &leds->cont[i];
+		led = &cont->led;
+
+		cont->id = i;
+		led->name = nintendo3ds_led_colors[i];
+		led->brightness_set_blocking = nintendo3ds_leds_setbrightness;
+
+		res = devm_led_classdev_register(&pdev->dev, led);
+		if (res < 0) {
+			dev_warn(&pdev->dev, "failed to register led device (%d)", res);
+			break;
+		}
+	}
+
+	return res;
+}
+
+static const struct of_device_id nintendo3ds_infoled_of_match[] = {
+    { .compatible = "nintendo3ds," DRIVER_NAME, },
+    {}
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_infoled_of_match);
+
+static struct platform_driver nintendo3ds_infoled_driver = {
+    .probe = nintendo3ds_infoled_probe,
+
+    .driver = {
+        .name = DRIVER_NAME,
+        .owner = THIS_MODULE,
+        .of_match_table = of_match_ptr(nintendo3ds_infoled_of_match),
+    },
+};
+module_platform_driver(nintendo3ds_infoled_driver);
+
+MODULE_AUTHOR("Wolfvak");
+MODULE_DESCRIPTION("Nintendo 3DS notification LED driver");
+MODULE_LICENSE("GPL");
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_mcu.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_mcu.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_mcu.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_mcu.c	2019-05-11 23:43:56.963635100 -0300
@@ -0,0 +1,135 @@
+/*
+ * nintendo3ds_mcu.c
+ *
+ * Copyright (C) 2019 Wolfvak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/regmap.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/miscdevice.h>
+
+#define DRIVER_NAME "nintendo3ds-mcu"
+
+static const struct regmap_range mcu_readable[] = {
+	regmap_reg_range(0, 0x1F),
+	regmap_reg_range(0x24, 0x2C),
+	regmap_reg_range(0x2E, 0x2E),
+	regmap_reg_range(0x30, 0x3E),
+	regmap_reg_range(0x40, 0x4B),
+	regmap_reg_range(0x7F, 0x7F),
+};
+static const struct regmap_access_table mcu_readable_table = {
+	.yes_ranges = mcu_readable,
+	.n_yes_ranges = ARRAY_SIZE(mcu_readable),
+};
+
+static const struct regmap_range mcu_writeable[] = {
+	regmap_reg_range(0x10, 0x13),
+	regmap_reg_range(0x18, 0x22),
+	regmap_reg_range(0x27, 0x2D),
+	regmap_reg_range(0x2F, 0x3B),
+	regmap_reg_range(0x7F, 0x7F),
+};
+static const struct regmap_access_table mcu_writeable_table = {
+	.yes_ranges = mcu_writeable,
+	.n_yes_ranges = ARRAY_SIZE(mcu_writeable),
+};
+
+static const struct regmap_range mcu_all[] = {
+	regmap_reg_range(0, 0x7F),
+};
+
+static const struct regmap_access_table mcu_all_table = {
+	.yes_ranges = mcu_all,
+	.n_yes_ranges = ARRAY_SIZE(mcu_all),
+};
+
+static const struct regmap_range mcu_noinc[] = {
+	regmap_reg_range(0x2D, 0x2D),
+};
+static const struct regmap_access_table mcu_noinc_table = {
+	.yes_ranges = mcu_noinc,
+	.n_yes_ranges = ARRAY_SIZE(mcu_noinc),
+};
+
+
+static const struct regmap_config regmap_mcu_cfg = {
+	.name = "n3ds_mcuregmap",
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0x7F,
+
+	.fast_io = true,
+
+	.rd_table = &mcu_readable_table,
+	.wr_table = &mcu_writeable_table,
+
+	.volatile_table = &mcu_all_table,
+	.precious_table = &mcu_all_table,
+
+	.wr_noinc_table = &mcu_noinc_table,
+	.rd_noinc_table = &mcu_noinc_table,
+};
+
+static int nintendo3ds_mcu_probe(struct i2c_client *i2c,
+					const struct i2c_device_id *id)
+{
+	struct device *dev = &i2c->dev;
+	struct regmap *mcu_regmap = devm_regmap_init_i2c(i2c, &regmap_mcu_cfg);
+	if (IS_ERR(mcu_regmap))
+		return PTR_ERR(mcu_regmap);
+
+	i2c_set_clientdata(i2c, mcu_regmap);
+	return devm_of_platform_populate(dev);
+}
+
+static const struct i2c_device_id nintendo3ds_mcu_id[] = {
+       { DRIVER_NAME, 0 },
+       { }
+};
+MODULE_DEVICE_TABLE(i2c, nintendo3ds_mcu_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id nintendo3ds_mcu_of_match[] = {
+	{.compatible = "nintendo3ds," DRIVER_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_mcu_of_match);
+#endif
+
+static struct i2c_driver nintendo3ds_mcu_driver = {
+	.probe = nintendo3ds_mcu_probe,
+	.id_table = nintendo3ds_mcu_id,
+
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(nintendo3ds_mcu_of_match),
+	},
+};
+
+static int __init nintendo3ds_mcu_init(void)
+{
+	return i2c_add_driver(&nintendo3ds_mcu_driver);
+}
+/* init early so consumer devices can complete system boot */
+subsys_initcall(nintendo3ds_mcu_init);
+
+static void __exit nintendo3ds_mcu_exit(void)
+{
+	i2c_del_driver(&nintendo3ds_mcu_driver);
+}
+module_exit(nintendo3ds_mcu_exit);
+
+MODULE_DESCRIPTION("Nintendo 3DS MCU system controller");
+MODULE_AUTHOR("Wolfvak");
+MODULE_LICENSE("GPL");
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_mcuhid.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_mcuhid.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_mcuhid.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_mcuhid.c	2019-05-11 19:28:42.006770400 -0300
@@ -0,0 +1,168 @@
+/*
+ *  nintendo3ds_mcuhid.c
+ *
+ *  Copyright (C) 2019 Wolfvak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/irqdomain.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-mcuhid"
+
+#define BTN_PWR_DOWN	BIT(0)
+#define BTN_PWR_HOLD	BIT(1)
+#define BTN_HOME_DOWN	BIT(2)
+#define BTN_WIFI_SWITCH	BIT(4)
+#define BTN_SHELL_CLOSE	BIT(5)
+
+#define BTN_MCU_ALL	\
+	(BTN_PWR_DOWN | BTN_PWR_HOLD | BTN_HOME_DOWN | \
+		BTN_WIFI_SWITCH | BTN_SHELL_CLOSE)
+
+#define MCU_MASK_REGISTER	(0x10)
+#define MCU_ACK_REGISTER	(0x18)
+
+struct nintendo3ds_mcuhid {
+	unsigned irq;
+	struct input_dev *input;
+	struct regmap *mcu_regmap;
+
+	struct work_struct work;
+};
+
+static const struct {
+	unsigned int in, out;
+} mcuhid_mappings[] = {
+	{BTN_PWR_DOWN, KEY_SUSPEND},
+	{BTN_PWR_HOLD, KEY_POWER},
+	{BTN_HOME_DOWN, KEY_HOME},
+	{BTN_WIFI_SWITCH, KEY_WWAN},
+	{BTN_SHELL_CLOSE, SW_LID},
+};
+
+static void nintendo3ds_mcuhid_report(struct work_struct *work)
+{
+	int i;
+	u32 mask;
+	struct nintendo3ds_mcuhid *mcuhid =
+		container_of(work, struct nintendo3ds_mcuhid, work);
+
+	regmap_raw_read(mcuhid->mcu_regmap, MCU_ACK_REGISTER,
+		&mask, sizeof(mask));
+
+	for (i = 0; i < ARRAY_SIZE(mcuhid_mappings); i++)
+		input_report_key(mcuhid->input, mcuhid_mappings[i].out,
+			mcuhid_mappings[i].in & mask);
+
+	input_sync(mcuhid->input);
+}
+
+static void nintendo3ds_mcuhid_setmask(struct nintendo3ds_mcuhid *mcuhid,
+										unsigned int mask)
+{
+	mask = ~mask;
+	regmap_raw_write(mcuhid->mcu_regmap, MCU_MASK_REGISTER,
+		&mask, sizeof(mask));
+}
+
+static irqreturn_t nintendo3ds_mcuhid_interrupt(int irq, void *priv)
+{
+	struct nintendo3ds_mcuhid *mcuhid = priv;
+	schedule_work(&mcuhid->work);
+	return IRQ_HANDLED;
+}
+
+static int nintendo3ds_mcuhid_probe(struct platform_device *pdev)
+{
+	int err, i;
+	unsigned irq;
+	struct input_dev *input;
+	struct regmap *mcu_regmap;
+	struct nintendo3ds_mcuhid *mcuhid;
+
+	mcu_regmap = dev_get_drvdata(pdev->dev.parent);
+	irq = platform_get_irq(pdev, 0);
+	if (!irq)
+		return -EINVAL;
+
+	mcuhid = devm_kzalloc(&pdev->dev, sizeof(*mcuhid), GFP_KERNEL);
+	if (IS_ERR(mcuhid))
+		return PTR_ERR(mcuhid);
+
+	mcuhid->mcu_regmap = mcu_regmap;
+	mcuhid->irq = irq;
+	INIT_WORK(&mcuhid->work, nintendo3ds_mcuhid_report);
+
+	input = devm_input_allocate_device(&pdev->dev);
+	input->name = "Nintendo 3DS MCU input";
+	input->id.bustype = BUS_HOST;
+	input->dev.parent = &pdev->dev;
+
+	mcuhid->input = input;
+
+	// enable all buttons
+	nintendo3ds_mcuhid_setmask(mcuhid, BTN_MCU_ALL);
+
+	set_bit(EV_KEY, input->evbit);
+	for (i = 0; i < ARRAY_SIZE(mcuhid_mappings); i++)
+		set_bit(mcuhid_mappings[i].out, input->keybit);
+
+	err = input_register_device(input);
+	if (err)
+		return err;
+
+	err = devm_request_irq(&pdev->dev, irq, nintendo3ds_mcuhid_interrupt,
+							0, "mcu_hid", mcuhid);
+	if (err) {
+		input_unregister_device(input);
+		return err;
+	}
+
+	platform_set_drvdata(pdev, mcuhid);
+	return 0;
+}
+
+static int nintendo3ds_mcuhid_remove(struct platform_device *pdev)
+{
+	struct nintendo3ds_mcuhid *mcuhid = platform_get_drvdata(pdev);
+	devm_free_irq(&pdev->dev, mcuhid->irq, mcuhid);
+	input_unregister_device(mcuhid->input);
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_mcuhid_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_mcuhid_of_match);
+
+static struct platform_driver nintendo3ds_mcuhid_driver = {
+	.probe	= nintendo3ds_mcuhid_probe,
+	.remove	= nintendo3ds_mcuhid_remove,
+
+	.driver	= {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = nintendo3ds_mcuhid_of_match,
+	},
+};
+
+module_platform_driver(nintendo3ds_mcuhid_driver);
+
+MODULE_DESCRIPTION("Nintendo 3DS MCU HID driver");
+MODULE_AUTHOR("Wolfvak");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_mmc.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_mmc.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_mmc.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_mmc.c	2019-05-04 18:53:35.969234800 -0300
@@ -0,0 +1,387 @@
+/*
+ * nintendo3ds_mmc.c
+ *
+ *  Copyright (C) 2019 Wolfvak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/of.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/genhd.h>
+#include <linux/blk-mq.h>
+#include <linux/errno.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+
+#include <mach/pxi.h>
+
+#define DRIVER_NAME "nintendo3ds-mmc"
+
+#define DEVICE_NAME "ctr_mmc"
+
+#define MMC_BLKSZ	(512)
+
+#define MMC_INIT_TIMEOUT	(1000)
+#define MMC_RDWR_TIMEOUT	(2500)
+
+#define NINTENDO3DS_MMC_FIRST_MINOR 0
+#define NINTENDO3DS_MMC_MINOR_COUNT 16
+
+#define PXI_MSG_INIT_FN	(0)
+#define PXI_MSG_SIZE_FN	(1)
+#define PXI_MSG_READ_FN	(2)
+#define PXI_MSG_WRITE_FN	(3)
+
+struct nintendo3ds_mmc_host;
+struct nintendo3ds_mmc_slot {
+	spinlock_t lock;
+
+	int slot;
+	sector_t size;
+
+	struct pxi_message *msg;
+
+	struct gendisk *gd;
+	struct request_queue *q;
+	struct blk_mq_tag_set tag_set;
+
+	struct nintendo3ds_mmc_host *host;
+};
+
+struct nintendo3ds_mmc_host {
+	struct pxi_channel *chan;
+	struct device *dev;
+
+	spinlock_t host_lock;
+
+	int major;
+
+	int slot_count;
+	struct nintendo3ds_mmc_slot *slot;
+};
+
+static int mmc_readwrite(struct nintendo3ds_mmc_slot *slot,
+		u32 offset, u32 count, dma_addr_t phys_addr, int write)
+{
+	int err;
+	u32 pxi_arg;
+	struct pxi_message *msg;
+	struct nintendo3ds_mmc_host *host;
+
+	host = slot->host;
+
+	/*msg = pxi_alloc_message(host->chan,
+		write ? PXI_MSG_WRITE_FN : PXI_MSG_READ_FN, 4);*/
+
+	msg = slot->msg;
+	pxi_set_fn(msg, write ? PXI_MSG_WRITE_FN : PXI_MSG_READ_FN);
+
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	pxi_set_arg(msg, 0, slot->slot);
+	pxi_set_arg(msg, 1, offset);
+	pxi_set_arg(msg, 2, count);
+	pxi_set_arg(msg, 3, phys_addr);
+
+	err = pxi_send_message(host->chan, msg);
+
+	if (!err) {
+		pxi_get_arg(msg, 0, &pxi_arg);
+		err = (pxi_arg == count) ? 0 : -EIO;
+	}
+
+	//pxi_free_message(host->chan, msg);
+
+	return err;
+}
+
+static int mmc_readwrite_mapaddr(struct nintendo3ds_mmc_slot *slot, u32 sector,
+								u32 count, void *buffer, int write)
+{
+	dma_addr_t phys;
+	int err, dma_dir;
+	struct device *dev;
+
+	dev = slot->host->dev;
+	dma_dir = write ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+
+	phys = dma_map_single(dev, buffer, count * MMC_BLKSZ, dma_dir);
+	if (dma_mapping_error(dev, phys))
+		return -ENOMEM;
+
+	err = mmc_readwrite(slot, sector, count, phys, write);
+
+	dma_unmap_single(dev, phys, count * MMC_BLKSZ, dma_dir);
+	return err;
+}
+
+static int mmc_xfer_bio(struct nintendo3ds_mmc_slot *slot, struct request *req)
+{
+	struct bio_vec bvec;
+	struct req_iterator i;
+
+	int dir = rq_data_dir(req);
+	sector_t sector = blk_rq_pos(req);
+
+	rq_for_each_segment(bvec, req, i) {
+		int ret;
+		sector_t sector_count = bvec.bv_len / MMC_BLKSZ;
+		char *buffer = kmap_atomic(bvec.bv_page);
+		unsigned long offset = bvec.bv_offset;
+
+		ret = mmc_readwrite_mapaddr(slot, sector, sector_count,
+									buffer + offset, dir == WRITE);
+
+		kunmap_atomic(buffer);
+
+		if (ret)
+			return ret;
+
+		sector += sector_count;
+	}
+
+	return 0;
+}
+
+static blk_status_t mmc_queue_rq(struct blk_mq_hw_ctx *hctx,
+							const struct blk_mq_queue_data *bd)
+{
+	int err;
+	blk_status_t status;
+	struct request *req;
+	struct nintendo3ds_mmc_slot *slot;
+
+	req = bd->rq;
+	blk_mq_start_request(req);
+	slot = req->rq_disk->private_data;
+
+	spin_lock(&slot->lock);
+	err = mmc_xfer_bio(slot, req);
+	if (err)
+		status = BLK_STS_IOERR;
+	else
+		status = BLK_STS_OK;
+	spin_unlock(&slot->lock);
+
+	blk_mq_end_request(req, status);
+	return status;
+}
+
+static const struct blk_mq_ops nintendo3ds_mq_ops = {
+	.queue_rq = mmc_queue_rq,
+};
+
+static int nintendo3ds_mmc_open(struct block_device *bdev, fmode_t mode)
+{
+	unsigned unit = iminor(bdev->bd_inode);
+
+	if (unit > NINTENDO3DS_MMC_MINOR_COUNT)
+		return -ENODEV;
+
+	return 0;
+}
+
+static void nintendo3ds_mmc_release(struct gendisk *disk, fmode_t mode)
+{
+}
+
+static const struct block_device_operations nintendo3ds_mmc_fops = {
+	.owner = THIS_MODULE,
+	.open = nintendo3ds_mmc_open,
+	.release = nintendo3ds_mmc_release,
+};
+
+static int mmc_slot_add(struct nintendo3ds_mmc_host *host,
+						sector_t size, unsigned int slotn)
+{
+	struct nintendo3ds_mmc_slot *slot;
+
+	if (slotn >= host->slot_count)
+		return -EINVAL;
+
+	slot = &host->slot[slotn];
+
+	slot->host = host;
+	slot->size = size;
+	slot->slot = slotn;
+	spin_lock_init(&slot->lock);
+
+	//slot->q = blk_init_queue(mmc_request, &slot->lock);
+	slot->q = blk_mq_init_sq_queue(&slot->tag_set, &nintendo3ds_mq_ops, 1, BLK_MQ_F_SHOULD_MERGE);
+	if (IS_ERR(slot->q)) {
+		dev_err(host->dev, "failed to allocate request queue");
+		return PTR_ERR(slot->q);
+	}
+
+	slot->q->queuedata = slot;
+
+	slot->gd = alloc_disk(NINTENDO3DS_MMC_MINOR_COUNT);
+	if (IS_ERR(slot->gd)) {
+		dev_err(host->dev, "failed to allocate slot");
+		blk_cleanup_queue(slot->q);
+	}
+
+	slot->gd->major = host->major;
+	slot->gd->first_minor = slotn * NINTENDO3DS_MMC_MINOR_COUNT;
+	slot->gd->fops = &nintendo3ds_mmc_fops;
+	slot->gd->private_data = slot;
+	slot->gd->queue = slot->q;
+	snprintf(slot->gd->disk_name, 32, DEVICE_NAME "_%c", slotn + 'a');
+	set_capacity(slot->gd, size);
+
+	slot->msg = pxi_alloc_message(host->chan, 0, 4);
+
+	add_disk(slot->gd);
+	return 0;
+}
+
+static int mmc_host_init(struct nintendo3ds_mmc_host *host)
+{
+	u32 pxi_arg;
+	int i, err, slotcnt;
+	struct pxi_message *msg;
+	struct nintendo3ds_mmc_slot *slots;
+
+	// initialize MMC controller
+	msg = pxi_alloc_message(host->chan, PXI_MSG_INIT_FN, 1);
+
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	err = pxi_send_message(host->chan, msg);
+	if (err) {
+		pxi_arg = 0;
+	} else {
+		pxi_get_arg(msg, 0, &pxi_arg);
+	}
+	pxi_free_message(host->chan, msg);
+	slotcnt = pxi_arg;
+	host->slot_count = slotcnt;
+
+	if (slotcnt <= 0)
+		return 0;
+
+	if (slotcnt > 2)
+		return -EINVAL;
+
+	// get sector counts
+	slots = devm_kzalloc(host->dev, sizeof(*slots) * slotcnt, GFP_KERNEL);
+	if (IS_ERR(slots))
+		return PTR_ERR(slots);
+
+	msg = pxi_alloc_message(host->chan, PXI_MSG_SIZE_FN, slotcnt);
+	if (IS_ERR(msg)) {
+		devm_kfree(host->dev, slots);
+		return PTR_ERR(msg);
+	}
+
+	host->slot = slots;
+
+	err = pxi_send_message(host->chan, msg);
+	for (i = 0; i < slotcnt && !err; i++) {
+		pxi_get_arg(msg, i, &pxi_arg);
+		if (pxi_arg == 0)
+			break;
+		err = mmc_slot_add(host, pxi_arg, i);
+	}
+	pxi_free_message(host->chan, msg);
+
+	return err;
+}
+
+static int nintendo3ds_mmc_probe(struct platform_device *pdev)
+{
+	int res, major = 0;
+	struct pxi_controller *pxi;
+	struct pxi_channel *pxi_chan;
+	struct nintendo3ds_mmc_host *mmc;
+
+	pxi = dev_get_drvdata(pdev->dev.parent);
+	if (pxi == NULL) {
+		dev_err(&pdev->dev, "failed to get PXI controller");
+		return -ENXIO;
+	}
+
+	pxi_chan = pxi_acq_channel(&pdev->dev, pxi, "sdmmc");
+	if (IS_ERR(pxi_chan)) {
+		dev_err(&pdev->dev, "failed to find PXI channel");
+		return -ENXIO;
+	}
+
+	major = register_blkdev(major, DEVICE_NAME);
+	if (major <= 0) {
+		dev_err(&pdev->dev, "failed to get major number");
+		return -EBUSY;
+	}
+
+	mmc = devm_kzalloc(&pdev->dev, sizeof(*mmc), GFP_KERNEL);
+	if (IS_ERR(mmc)) {
+		dev_err(&pdev->dev, "failed to allocate driver");
+		return PTR_ERR(mmc);
+	}
+
+	mmc->chan = pxi_chan;
+	mmc->dev = &pdev->dev;
+	mmc->major = major;
+
+	res = mmc_host_init(mmc);
+	if (res != 0) {
+		dev_err(&pdev->dev, "failed to initialize MMC");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int nintendo3ds_mmc_remove(struct platform_device *pdev)
+{
+	struct nintendo3ds_mmc_host *host = dev_get_drvdata(&pdev->dev);
+
+	BUG_ON(host == NULL);
+
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_mmc_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_mmc_of_match);
+
+static struct platform_driver nintendo3ds_mmc_driver = {
+	.probe	= nintendo3ds_mmc_probe,
+	.remove = nintendo3ds_mmc_remove,
+
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = nintendo3ds_mmc_of_match,
+	},
+};
+
+module_platform_driver(nintendo3ds_mmc_driver);
+
+MODULE_AUTHOR("Wolfvak");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Nintendo 3DS PXI SD/MMC driver");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_pxi.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_pxi.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_pxi.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_pxi.c	2019-05-04 18:53:35.970242800 -0300
@@ -0,0 +1,564 @@
+/*
+ *  nintendo3ds_pxi.c
+ *
+ *  Copyright (C) 2016 Sergi Granell <xerpi.g.12@gmail.com>
+ *  Copyright (C) 2018 Wolfvak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <asm/io.h>
+#include <linux/of.h>
+#include <linux/mutex.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/genalloc.h>
+#include <linux/interrupt.h>
+#include <linux/irqdomain.h>
+#include <linux/dma-mapping.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+
+#include <linux/mailbox_controller.h>
+
+#include <mach/pxi.h>
+#include <mach/platform.h>
+
+#define DRIVER_NAME "nintendo3ds-pxi"
+
+
+/* hardware specific register peek / pokes */
+#define REG_SYNC32_OFF		(0)
+#define REG_SYNC_RX_OFF		(0)
+#define REG_SYNC_TX_OFF		(1)
+#define REG_SYNC_CNT_OFF	(3)
+
+#define REG_CNT_OFF	(0x4)
+#define REG_TX_OFF	(0x8)
+#define REG_RX_OFF	(0xC)
+
+#define CNT_TX_FLUSH		(1 << 3)
+#define CNT_RX_AVAIL_IRQ	(1 << 10)
+#define CNT_FIFO_ENABLE		(1 << 15)
+
+#define SYNC_TRIGGER_IRQ	(1 << 6)
+#define SYNC_IRQ_ENABLE		(1 << 7)
+#define SYNC_SET_BITS		(SYNC_TRIGGER_IRQ | SYNC_IRQ_ENABLE)
+
+#define PXI_TX_EMPTY(io)	(ioread16((io) + REG_CNT_OFF) & (1 << 0))
+#define PXI_TX_FULL(io)		(ioread16((io) + REG_CNT_OFF) & (1 << 1))
+#define PXI_RX_EMPTY(io)	(ioread16((io) + REG_CNT_OFF) & (1 << 8))
+#define PXI_RX_FULL(io)		(ioread16((io) + REG_CNT_OFF) & (1 << 9))
+
+#define PXI_RX(io)			ioread32((io) + REG_RX_OFF)
+#define PXI_TX(w, io)		iowrite32((w), (io) + REG_TX_OFF)
+
+#define PXI_SYNC_RX(io)		ioread8((io) + REG_SYNC_RX_OFF)
+#define PXI_SYNC_TX(b, io)	iowrite8((b), (io) + REG_SYNC_TX_OFF)
+#define PXI_TRIGGERSYNC(io)	iowrite8(SYNC_SET_BITS, (io) + REG_SYNC_CNT_OFF)
+
+
+// software defined stuff
+#define PXI_CHAN_MAX	(8)
+#define PXI_CHAN_NAMESZ	(16)
+
+#define PXI_MSG_MAXARG	(14)
+
+#define PXI_ST_TIMEOUT	(msecs_to_jiffies(50))
+#define PXI_ACK_TIME	(msecs_to_jiffies(100))
+#define PXI_DONE_TIME	(msecs_to_jiffies(2500))
+static DECLARE_WAIT_QUEUE_HEAD(pxi_remote_wait);
+
+static DEFINE_SPINLOCK(pxi_txrx_lock);
+
+struct pxi_controller;
+struct pxi_channel {
+	struct pxi_controller *controller;
+
+	char name[PXI_CHAN_NAMESZ];
+	int dev_id;
+
+	struct device *owner;
+	spinlock_t lock;
+};
+
+struct pxi_controller {
+	struct device *dev;
+	void __iomem *base;
+	unsigned sync_irq, rx_irq;
+
+	unsigned int chan_cnt;
+	struct pxi_channel *chans;
+};
+
+struct pxi_hwmsg {
+	u32 virt_addr;
+
+	u8 dev;
+	u8 func;
+
+	s8 state;
+	u8 argc;
+
+	// currently hardcoded, should be variable sized
+	u32 args[PXI_MSG_MAXARG];
+} __attribute__((packed)) __attribute__((aligned(8)));
+
+struct pxi_message {
+	struct completion ackd;
+	struct completion done;
+
+	dma_addr_t msg_phys;
+	struct pxi_hwmsg *msg_virt;
+};
+
+
+// pxi messaging stuff
+static int pxi_tx_data(char __iomem *io, u32 data)
+{
+	int err;
+
+	spin_lock(&pxi_txrx_lock);
+	if (likely(!PXI_TX_FULL(io))) {
+		PXI_TX(data, io);
+		err = 0;
+	} else {
+		err = -EBUSY;
+	}
+	spin_unlock(&pxi_txrx_lock);
+
+	return err;
+}
+
+static struct pxi_message *int_pxi_alloc_message(struct device *dev,
+												u32 argc)
+{
+	dma_addr_t hwmsg_phys;
+	struct pxi_message *msg;
+	struct pxi_hwmsg *hwmsg;
+
+	msg = devm_kzalloc(dev, sizeof(*msg), GFP_KERNEL);
+	if (IS_ERR(msg))
+		return ERR_CAST(msg);
+
+	hwmsg = dmam_alloc_coherent(dev, sizeof(*hwmsg),
+								&hwmsg_phys, GFP_KERNEL);
+	if (IS_ERR(hwmsg)) {
+		devm_kfree(dev, msg);
+		return ERR_CAST(hwmsg);
+	}
+
+	init_completion(&msg->ackd);
+	init_completion(&msg->done);
+
+	msg->msg_phys = hwmsg_phys;
+	msg->msg_virt = hwmsg;
+
+	hwmsg->virt_addr = (u32)msg;
+	hwmsg->argc = argc;
+
+	return msg;
+}
+
+static void int_pxi_free_message(struct device *dev,
+								struct pxi_message *msg)
+{
+	dmam_free_coherent(dev, sizeof(*(msg->msg_virt)),
+						msg->msg_virt, msg->msg_phys);
+	devm_kfree(dev, msg);
+}
+
+static int int_pxi_send_message(struct device *dev,
+								char __iomem *io,
+								struct pxi_message *msg)
+{
+	int err;
+	long timeout;
+
+	reinit_completion(&msg->ackd);
+	reinit_completion(&msg->done);
+	msg->msg_virt->state = 0;
+	smp_wmb();
+
+	err = pxi_tx_data(io, msg->msg_phys);
+	if (err)
+		return err;
+
+	// three cases:
+	// ackd and state > 0 => processing
+	// ackd and state < 0 => try again
+	// not ackd => timed out, fw is probably dead/locked
+	timeout = wait_for_completion_interruptible_timeout(
+		&msg->ackd, PXI_ACK_TIME);
+	if (likely(timeout > 0)) {
+		int state = msg->msg_virt->state;
+		smp_rmb();
+		if (likely(state > 0)) {
+			timeout = wait_for_completion_interruptible_timeout(
+				&msg->done, PXI_DONE_TIME);
+			if (likely(timeout > 0)) {
+				err = 0;
+			} else {
+				err = -EIO;
+			}
+		} else if (state < 0) {
+			err = -EAGAIN;
+		} else {
+			err = -EINVAL;
+		}
+	} else {
+		err = -ETIMEDOUT;
+	}
+
+	return err;
+}
+
+struct pxi_message *pxi_alloc_message(struct pxi_channel *chan,
+										u8 function, u32 argc)
+{
+	struct pxi_message *msg;
+	struct pxi_controller *pxi;
+
+	if (!chan || function == 0xFF || argc > PXI_MSG_MAXARG)
+		return ERR_PTR(-EINVAL);
+
+	pxi = chan->controller;
+	msg = int_pxi_alloc_message(chan->owner, argc);
+
+	if (IS_ERR(msg))
+		return ERR_PTR(-ENOMEM);
+
+	msg->msg_virt->dev = chan->dev_id;
+	msg->msg_virt->func = function;
+	return msg;
+}
+EXPORT_SYMBOL(pxi_alloc_message);
+
+void pxi_free_message(struct pxi_channel *chan, struct pxi_message *msg)
+{
+	if (!chan || !msg)
+		return;
+
+	int_pxi_free_message(chan->owner, msg);
+}
+EXPORT_SYMBOL(pxi_free_message);
+
+int pxi_send_message(struct pxi_channel *chan, struct pxi_message *msg)
+{
+	if (!chan || !msg)
+		return -EINVAL;
+
+	return int_pxi_send_message(chan->owner, chan->controller->base, msg);
+}
+EXPORT_SYMBOL(pxi_send_message);
+
+int pxi_set_fn(struct pxi_message *msg, u8 fn)
+{
+	if (!msg || fn == 0xFF)
+		return -EINVAL;
+
+	msg->msg_virt->func = fn;
+	return 0;
+}
+EXPORT_SYMBOL(pxi_set_fn);
+
+int pxi_set_arg(struct pxi_message *msg, unsigned i, u32 val)
+{
+	if (msg && i < msg->msg_virt->argc) {
+		msg->msg_virt->args[i] = val;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(pxi_set_arg);
+
+int pxi_get_arg(struct pxi_message *msg, unsigned i, u32 *val)
+{
+	if (msg && i < msg->msg_virt->argc) {
+		if (val)
+			*val = msg->msg_virt->args[i];
+		return 0;
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(pxi_get_arg);
+
+struct pxi_channel *pxi_acq_channel(struct device *dev,
+									struct pxi_controller *pxi,
+									const char *devname)
+{
+	int i, err;
+	struct pxi_channel *chan;
+
+	if (!pxi || !devname)
+		return ERR_PTR(-EINVAL);
+
+	for (i = 0; i < pxi->chan_cnt; i++) {
+		chan = &pxi->chans[i];
+		if (!strcmp(chan->name, devname))
+			break;
+	}
+
+	if (i == pxi->chan_cnt)
+		return ERR_PTR(-ENXIO);
+
+	err = spin_trylock(&chan->lock);
+	if (!err)
+		return ERR_PTR(-EBUSY);
+
+	chan->owner = dev;
+	return chan;
+}
+EXPORT_SYMBOL(pxi_acq_channel);
+
+int pxi_rel_channel(struct pxi_channel *chan)
+{
+	spin_unlock(&chan->lock);
+	return 0;
+}
+EXPORT_SYMBOL(pxi_rel_channel);
+
+
+// interrupt handlers
+static irqreturn_t pxi_rx_handler(int irq, void *priv)
+{
+	struct pxi_controller *pxi = priv;
+	char __iomem *io = pxi->base;
+
+	while(1) {
+		struct pxi_message *msg;
+
+		spin_lock(&pxi_txrx_lock);
+		msg = PXI_RX_EMPTY(io) ? NULL : (void*)PXI_RX(io);
+		spin_unlock(&pxi_txrx_lock);
+
+		if (!msg)
+			break;
+
+		smp_rmb();
+		complete_all(completion_done(&msg->ackd) ?
+					&msg->done : &msg->ackd);
+		smp_wmb();
+	}
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t pxi_sync_handler(int irq, void *priv)
+{
+	wake_up_all(&pxi_remote_wait);
+	return IRQ_HANDLED;
+}
+
+
+// hardware testing & reset
+static int pxi_self_test(struct pxi_controller *pxi)
+{
+	int err;
+	unsigned int i;
+	char __iomem *io = pxi->base;
+
+	err = devm_request_irq(pxi->dev, pxi->sync_irq, pxi_sync_handler,
+							0, "pxi_sync", pxi);
+	if (err)
+		return err;
+
+	for (i = 0; i < 256; i += 7) {
+		PXI_SYNC_TX(i, io);
+		PXI_TRIGGERSYNC(io);
+
+		if (wait_event_interruptible_timeout(pxi_remote_wait,
+			PXI_SYNC_RX(io) == (0xFF - i), PXI_ST_TIMEOUT) <= 0) {
+			err = -ETIMEDOUT;
+			break;
+		}
+	}
+
+	devm_free_irq(pxi->dev, pxi->sync_irq, pxi);
+	return err;
+}
+
+static void pxi_reset_regs(struct pxi_controller *pxi)
+{
+	int i;
+	char __iomem *io = pxi->base;
+
+	iowrite32(0, io + REG_SYNC32_OFF);
+	iowrite16(CNT_TX_FLUSH | CNT_FIFO_ENABLE, io + REG_CNT_OFF);
+
+	for (i = 0; i < 16; i++)
+		PXI_RX(io);
+
+	iowrite16(0, io + REG_CNT_OFF);
+	iowrite16(CNT_RX_AVAIL_IRQ | CNT_FIFO_ENABLE,
+		io + REG_CNT_OFF);
+}
+
+static int pxi_discover_devs(struct pxi_controller *pxi, unsigned chan_cnt)
+{
+	int err;
+	unsigned chan_i;
+	struct device *dev;
+	struct pxi_channel *chans;
+	struct pxi_message *discover_msg;
+
+	dev = pxi->dev;
+
+	if (!chan_cnt) {
+		pxi->chan_cnt = 0;
+		pxi->chans = NULL;
+		return 0;
+	}
+
+	chans = devm_kzalloc(dev,
+		sizeof(*chans) * chan_cnt, GFP_KERNEL);
+
+	if (!chans)
+		return -ENOMEM;
+
+	discover_msg = int_pxi_alloc_message(dev, PXI_CHAN_NAMESZ / 4);
+	if (!discover_msg) {
+		devm_kfree(dev, chans);
+		return -ENOMEM;
+	}
+
+	discover_msg->msg_virt->func = 0xFF;
+	for (chan_i = 0; chan_i < chan_cnt; chan_i++) {
+		discover_msg->msg_virt->dev = chan_i;
+		err = int_pxi_send_message(dev, pxi->base, discover_msg);
+		if (err)
+			break;
+
+		chans[chan_i].controller = pxi;
+		chans[chan_i].dev_id = chan_i;
+		strlcpy(chans[chan_i].name, (const char*)&discover_msg->msg_virt->args[0],
+				PXI_CHAN_NAMESZ - 1);
+
+		dev_info(dev, "discovered \"%s\"", chans[chan_i].name);
+	}
+
+	if (!err) {
+		pxi->chan_cnt = chan_cnt;
+		pxi->chans = chans;
+	}
+
+	int_pxi_free_message(dev, discover_msg);
+	return err;
+}
+
+static int pxi_startup(struct pxi_controller *pxi)
+{
+	int err;
+	u32 chan_cnt;
+	struct device *dev;
+	struct pxi_message *ident_msg;
+
+	dev = pxi->dev;
+
+	err = devm_request_irq(dev, pxi->rx_irq, pxi_rx_handler,
+							0, "pxi_rx", pxi);
+	if (err)
+		return err;
+
+	// get device count
+	ident_msg = int_pxi_alloc_message(dev, 1);
+	if (IS_ERR(ident_msg))
+		return PTR_ERR(ident_msg);
+
+	// set device to 0xFF, discovery device
+	ident_msg->msg_virt->dev = 0xFF;
+	pxi_set_arg(ident_msg, 0, 0xFFFFFFFF);
+
+	err = int_pxi_send_message(dev, pxi->base, ident_msg);
+	pxi_get_arg(ident_msg, 0, &chan_cnt);
+	int_pxi_free_message(dev, ident_msg);
+
+	if (err)
+		return err;
+
+	dev_info(pxi->dev, "found %d devices", chan_cnt);
+	return pxi_discover_devs(pxi, chan_cnt);
+}
+
+
+// driver management
+static int nintendo3ds_pxi_probe(struct platform_device *pdev)
+{
+	int err;
+	void __iomem *io_regs;
+	struct resource *memres;
+	struct pxi_controller *pxi;
+
+	struct device_node *np;
+
+	pxi = devm_kzalloc(&pdev->dev, sizeof(*pxi), GFP_KERNEL);
+	if (IS_ERR(pxi))
+		return PTR_ERR(pxi);
+
+	// get resources and map registers into address space
+	memres = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(memres)) {
+		dev_err(&pdev->dev, "failed to get memory resource");
+		return PTR_ERR(memres);
+	}
+
+	io_regs = devm_ioremap_resource(&pdev->dev, memres);
+	if (IS_ERR(io_regs)) {
+		dev_err(&pdev->dev, "failed to map registers");
+		return PTR_ERR(io_regs);
+	}
+
+	pxi->dev = &pdev->dev;
+	pxi->base = io_regs;
+	pxi->sync_irq = platform_get_irq(pdev, 0);
+	pxi->rx_irq = platform_get_irq(pdev, 1);
+	dev_set_drvdata(&pdev->dev, pxi);
+
+	// reset hardware to a known good state
+	pxi_reset_regs(pxi);
+
+	// run self-test
+	err = pxi_self_test(pxi);
+	if (err) {
+		dev_err(&pdev->dev, "self test failed");
+		return err;
+	}
+
+	err = pxi_startup(pxi);
+	if (err) {
+		dev_err(&pdev->dev, "failed to init PXI controller");
+		return err;
+	}
+
+	np = pdev->dev.of_node;
+	if (np)
+		of_platform_populate(np, NULL, NULL, &pdev->dev);
+
+	return 0;
+}
+
+static int nintendo3ds_pxi_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_pxi_of_match[] = {
+		{ .compatible = "nintendo3ds," DRIVER_NAME, },
+		{},
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_pxi_of_match);
+
+static struct platform_driver nintendo3ds_pxi_driver = {
+	.probe	= nintendo3ds_pxi_probe,
+	.remove = nintendo3ds_pxi_remove,
+
+	.driver	= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table	= of_match_ptr(nintendo3ds_pxi_of_match),
+	},
+};
+module_platform_driver(nintendo3ds_pxi_driver);
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_reset.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_reset.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_reset.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_reset.c	2019-05-09 19:36:03.099457400 -0300
@@ -0,0 +1,68 @@
+/*
+ *  nintendo3ds_reset.c
+ *
+ *  Copyright (C) 2016 Sergi Granell
+ *  based on msm-poweroff.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/pm.h>
+#include <linux/reboot.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-reset"
+#define POWER_REGISTER	0x20
+
+static struct regmap *mcu_regmap;
+static int reset_restart(struct notifier_block *nb, unsigned long act,
+			   void *data)
+{
+	regmap_write(mcu_regmap, POWER_REGISTER, 0x04);
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block restart_nb = {
+	.notifier_call = reset_restart,
+	.priority = 128,
+};
+
+static void reset_poweroff(void)
+{
+	regmap_write(mcu_regmap, POWER_REGISTER, 0x01);
+}
+
+static int nintendo3ds_reset_probe(struct platform_device *pdev)
+{
+	mcu_regmap = dev_get_drvdata(pdev->dev.parent);
+
+	register_restart_handler(&restart_nb);
+	pm_power_off = reset_poweroff;
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_reset_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{}
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_reset_of_match);
+
+static struct platform_driver nintendo3ds_reset_driver = {
+	.probe = nintendo3ds_reset_probe,
+
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(nintendo3ds_reset_of_match),
+	},
+};
+module_platform_driver(nintendo3ds_reset_driver);
+
+MODULE_DESCRIPTION("Nintendo 3DS power control driver");
+MODULE_AUTHOR("Sergi Granell, <xerpi.g.12@gmail.com>");
+MODULE_LICENSE("GPL");
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_rng.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_rng.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_rng.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_rng.c	2019-05-11 23:34:58.673594200 -0300
@@ -0,0 +1,121 @@
+/*
+ * nintendo3ds_rng - Random Number Generator driver for the Nintendo 3DS
+ *
+ * Copyright 2019 (C) Wolfvak
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/hw_random.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/of.h>
+
+#include <mach/pxi.h>
+
+#define DRIVER_NAME "nintendo3ds-rng"
+
+// the hwrng driver always requests at least 32 bytes / 8 words
+#define RNG_WORDPERMSG	8
+
+struct nintendo3ds_rng {
+	struct device *dev;
+	struct pxi_channel *chan;
+
+	struct hwrng rng;
+};
+
+static int nintendo3ds_rng_read(struct hwrng *rng, void *buf,
+								size_t max, bool wait)
+{
+	int ret;
+	u32 *data;
+	struct pxi_message *msg;
+	struct nintendo3ds_rng *rng_dev;
+
+	data = buf;
+	rng_dev = container_of(rng, struct nintendo3ds_rng, rng);
+
+	msg = pxi_alloc_message(rng_dev->chan, 0, RNG_WORDPERMSG);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	ret = pxi_send_message(rng_dev->chan, msg);
+	if (!ret) {
+		int i;
+		for (i = 0; i < RNG_WORDPERMSG; i++)
+			pxi_get_arg(msg, i, &data[i]);
+		ret = RNG_WORDPERMSG * 4;
+	}
+	pxi_free_message(rng_dev->chan, msg);
+	return ret;
+}
+
+static int nintendo3ds_rng_probe(struct platform_device *pdev)
+{
+	int err;
+	struct pxi_channel *chan;
+	struct pxi_controller *pxi;
+	struct nintendo3ds_rng *rng;
+
+	rng = devm_kzalloc(&pdev->dev, sizeof(*rng), GFP_KERNEL);
+	if (!rng)
+		return -ENOMEM;
+
+	pxi = dev_get_drvdata(pdev->dev.parent);
+	if (!pxi)
+		return -EINVAL;
+
+	chan = pxi_acq_channel(&pdev->dev, pxi, "prng");
+	if (IS_ERR(chan))
+		return PTR_ERR(chan);
+
+	rng->dev = &pdev->dev;
+	rng->chan = chan;
+
+	rng->rng.name = DRIVER_NAME;
+	rng->rng.read = nintendo3ds_rng_read;
+
+	err = devm_hwrng_register(&pdev->dev, &rng->rng);
+	if (err) {
+		pxi_rel_channel(rng->chan);
+		return err;
+	}
+
+	platform_set_drvdata(pdev, rng);
+	return 0;
+}
+
+static int nintendo3ds_rng_remove(struct platform_device *pdev)
+{
+	struct nintendo3ds_rng *rng = platform_get_drvdata(pdev);
+	pxi_rel_channel(rng->chan);
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_rng_dt_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_rng_dt_match);
+
+static struct platform_driver nintendo3ds_rng_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.of_match_table = nintendo3ds_rng_dt_match,
+	},
+	.probe		= nintendo3ds_rng_probe,
+	.remove		= nintendo3ds_rng_remove,
+};
+module_platform_driver(nintendo3ds_rng_driver);
+
+MODULE_DESCRIPTION("Nintendo 3DS Hardware Random Number Generator driver");
+MODULE_AUTHOR("Wolfvak");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_rtc.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_rtc.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_rtc.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_rtc.c	2019-05-07 12:38:39.730081200 -0300
@@ -0,0 +1,115 @@
+/*
+ *  nintendo3ds_rtc.c
+ *
+ *  Copyright (C) 2016 Sergi Granell
+ *  based on rtc-em3207.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-rtc"
+
+#define RTC_REGISTER	0x30
+
+struct nintendo3ds_rtc {
+	struct regmap *mcu_regmap;
+	struct rtc_device *rtc_dev;
+};
+
+static int nintendo3ds_rtc_get_time(struct device *dev, struct rtc_time *tm)
+{
+	struct nintendo3ds_rtc *n3ds_rtc = dev_get_drvdata(dev);
+	struct regmap *mcu_regmap = n3ds_rtc->mcu_regmap;
+	int error;
+	u8 buf[8];
+
+	error = regmap_raw_read(mcu_regmap, RTC_REGISTER, buf, sizeof(buf));
+	if (error)
+		return error;
+
+	tm->tm_sec	= bcd2bin(buf[0]) % 60;
+	tm->tm_min	= bcd2bin(buf[1]) % 60;
+	tm->tm_hour	= bcd2bin(buf[2]) % 24;
+	tm->tm_mday	= bcd2bin(buf[4]) % 32;
+	tm->tm_mon	= (bcd2bin(buf[5]) - 1) % 12;
+	tm->tm_year	= bcd2bin(buf[6]) + 100;
+	return 0;
+}
+
+static int nintendo3ds_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct nintendo3ds_rtc *n3ds_rtc = dev_get_drvdata(dev);
+	struct regmap *mcu_regmap = n3ds_rtc->mcu_regmap;
+	u8 buf[8];
+
+	buf[0] = bin2bcd(tm->tm_sec);
+	buf[1] = bin2bcd(tm->tm_min);
+	buf[2] = bin2bcd(tm->tm_hour);
+	buf[4] = bin2bcd(tm->tm_mday);
+	buf[5] = bin2bcd(tm->tm_mon + 1);
+	buf[6] = bin2bcd(tm->tm_year - 100);
+
+	return regmap_raw_write(mcu_regmap, RTC_REGISTER, buf, sizeof(buf));
+}
+
+static const struct rtc_class_ops nintendo3ds_rtc_ops = {
+	.read_time	= nintendo3ds_rtc_get_time,
+	.set_time	= nintendo3ds_rtc_set_time,
+};
+
+static int nintendo3ds_rtc_probe(struct platform_device *pdev)
+{
+	struct rtc_device *rtc;
+	struct nintendo3ds_rtc *n3ds_rtc;
+	struct regmap *mcu_regmap = dev_get_drvdata(pdev->dev.parent);
+
+	n3ds_rtc = devm_kzalloc(&pdev->dev, sizeof(*n3ds_rtc), GFP_KERNEL);
+	if (IS_ERR(n3ds_rtc))
+		return PTR_ERR(n3ds_rtc);
+
+	n3ds_rtc->mcu_regmap = mcu_regmap;
+
+	platform_set_drvdata(pdev, n3ds_rtc);
+
+	rtc = devm_rtc_device_register(&pdev->dev, DRIVER_NAME,
+		&nintendo3ds_rtc_ops, THIS_MODULE);
+
+	if (IS_ERR(rtc))
+		return PTR_ERR(rtc);
+
+	n3ds_rtc->rtc_dev = rtc;
+	return 0;
+}
+
+static int __exit nintendo3ds_rtc_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_rtc_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{}
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_rtc_of_match);
+
+static struct platform_driver nintendo3ds_rtc_driver = {
+	.probe = nintendo3ds_rtc_probe,
+	.remove = nintendo3ds_rtc_remove,
+
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(nintendo3ds_rtc_of_match),
+	},
+};
+module_platform_driver(nintendo3ds_rtc_driver);
diff -Naur '--exclude=certs' linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_spi.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_spi.c
--- linux-5.0.3/drivers/platform/nintendo3ds/nintendo3ds_spi.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_spi.c	2019-05-08 11:05:25.692962000 -0300
@@ -0,0 +1,325 @@
+/*
+ *  nintendo3ds_spi.c
+ *
+ *  Copyright (C) 2016 Sergi Granell (xerpi)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+
+#define DRIVER_NAME "nintendo3ds-spi"
+
+struct nintendo3ds_spi {
+	struct spi_master	*master;
+	void __iomem		*base_addr;
+	u32			current_cs;
+};
+
+/* SPI registers */
+
+#define SPI_REG_NEW_CNT_OFFSET		0x800
+#define SPI_REG_NEW_DONE_OFFSET		0x804
+#define SPI_REG_NEW_BLKLEN_OFFSET	0x808
+#define SPI_REG_NEW_FIFO_OFFSET		0x80C
+#define SPI_REG_NEW_STATUS_OFFSET	0x810
+
+#define SPI_NEW_CNT_SELECT_DEVICE(n)	(n << 6)
+#define SPI_NEW_CNT_TRANSFER_IN		(0 << 13)
+#define SPI_NEW_CNT_TRANSFER_OUT	(1 << 13)
+#define SPI_NEW_CNT_BUSY		BIT(15)
+#define SPI_NEW_CNT_ENABLE		BIT(15)
+
+#define SPI_NEW_STATUS_FIFO_BUSY	BIT(0)
+
+static inline u32 spi_reg_new_cnt_read(void __iomem *base)
+{
+	return readl(base + SPI_REG_NEW_CNT_OFFSET);
+}
+static inline void spi_reg_new_cnt_write(void __iomem *base, u32 val)
+{
+	writel(val, base + SPI_REG_NEW_CNT_OFFSET);
+}
+
+static inline u32 spi_reg_new_done_read(void __iomem *base)
+{
+	return readl(base + SPI_REG_NEW_DONE_OFFSET);
+}
+static inline void spi_reg_new_done_write(void __iomem *base, u32 val)
+{
+	writel(val, base + SPI_REG_NEW_DONE_OFFSET);
+}
+
+static inline u32 spi_reg_new_blklen_read(void __iomem *base)
+{
+	return readl(base + SPI_REG_NEW_BLKLEN_OFFSET);
+}
+static inline void spi_reg_new_blklen_write(void __iomem *base, u32 val)
+{
+	writel(val, base + SPI_REG_NEW_BLKLEN_OFFSET);
+}
+
+static inline u32 spi_reg_new_fifo_read(void __iomem *base)
+{
+	return readl(base + SPI_REG_NEW_FIFO_OFFSET);
+}
+static inline void spi_reg_new_fifo_write(void __iomem *base, u32 val)
+{
+	writel(val, base + SPI_REG_NEW_FIFO_OFFSET);
+}
+
+static inline u32 spi_reg_new_status_read(void __iomem *base)
+{
+	return readl(base + SPI_REG_NEW_STATUS_OFFSET);
+}
+static inline void spi_reg_new_status_write(void __iomem *base, u32 val)
+{
+	writel(val, base + SPI_REG_NEW_STATUS_OFFSET);
+}
+
+static inline void spi_wait_new_cnt_busy(void __iomem *base)
+{
+	while (spi_reg_new_cnt_read(base) & SPI_NEW_CNT_BUSY)
+		;
+}
+
+static inline void spi_wait_new_fifo_busy(void __iomem *base)
+{
+	while (spi_reg_new_status_read(base) & SPI_NEW_STATUS_FIFO_BUSY)
+		;
+}
+
+static u8 spi_get_device_bits(u8 device_id)
+{
+	if (device_id < 6) {
+		if (device_id == 0 || device_id == 3) {
+			return 0;
+		} else if (device_id == 1 || device_id == 4) {
+			return 0x40;
+		} else if (device_id == 2 || device_id == 5) {
+			return 0x80;
+		}
+	}
+	return 0;
+}
+
+static u8 spi_get_baudrate_for_freq(u32 freq)
+{
+	switch (freq) {
+	case 4000000:
+		return 5;
+	case 2000000:
+		return 4;
+	case 1000000:
+		return 3;
+	case 512000:
+		return 2;
+	case 256000:
+		return 1;
+	case 128000:
+	default:
+		return 0;
+	}
+}
+
+struct nintendo3ds_spi_msg {
+	u32 baudrate;
+	void *buffer;
+	u32 size;
+	u8  device;
+};
+
+static void nintendo3ds_spi_write_msg(void __iomem *base, const struct nintendo3ds_spi_msg *msg)
+{
+	u32 device_bits;
+	u32 count;
+	u32 buffer_idx;
+
+	device_bits = spi_get_device_bits(msg->device);
+
+	spi_wait_new_cnt_busy(base);
+
+	spi_reg_new_blklen_write(base, msg->size);
+	spi_reg_new_cnt_write(base, msg->baudrate | device_bits
+		| SPI_NEW_CNT_ENABLE | SPI_NEW_CNT_TRANSFER_OUT);
+
+	if (msg->size > 0) {
+		count = 0;
+		do {
+			if ((count & 0x1F) == 0) {
+				spi_wait_new_fifo_busy(base);
+			}
+			buffer_idx = count & ~0b11;
+			count = count + 4;
+			spi_reg_new_fifo_write(base, *(u32 *)
+				(msg->buffer + buffer_idx));
+		} while (count < msg->size);
+	}
+
+	spi_wait_new_cnt_busy(base);
+}
+
+static void nintendo3ds_spi_read_msg(void __iomem *base, struct nintendo3ds_spi_msg *msg)
+{
+	u32 device_bits;
+	u32 count;
+	u32 buffer_idx;
+
+	device_bits = spi_get_device_bits(msg->device);
+
+	spi_wait_new_cnt_busy(base);
+
+	spi_reg_new_blklen_write(base, msg->size);
+	spi_reg_new_cnt_write(base, msg->baudrate | device_bits
+		| SPI_NEW_CNT_ENABLE | SPI_NEW_CNT_TRANSFER_IN);
+
+	if (msg->size > 0) {
+		count = 0;
+		do {
+			if ((count & 0x1F) == 0) {
+				spi_wait_new_fifo_busy(base);
+			}
+			buffer_idx = count & ~0b11;
+			count = count + 4;
+			*(u32 *)(msg->buffer + buffer_idx) =
+				spi_reg_new_fifo_read(base);
+		} while (count < msg->size);
+	}
+
+	spi_wait_new_cnt_busy(base);
+}
+
+static inline void nintendo3ds_spi_msg_done(void __iomem *base)
+{
+	spi_reg_new_done_write(base, 0);
+}
+
+static void nintendo3ds_spi_set_cs(struct spi_device *spi, bool enable)
+{
+	struct nintendo3ds_spi *n3ds_spi = spi_master_get_devdata(spi->master);
+
+	n3ds_spi->current_cs = spi->chip_select;
+}
+
+static int nintendo3ds_spi_transfer_one(struct spi_master *master,
+				  struct spi_device *spi,
+				  struct spi_transfer *tfr)
+{
+
+	struct nintendo3ds_spi_msg n3ds_msg;
+	struct nintendo3ds_spi *n3ds_spi = spi_master_get_devdata(master);
+
+	n3ds_msg.size = tfr->len;
+	n3ds_msg.baudrate = spi_get_baudrate_for_freq(spi->max_speed_hz);
+	n3ds_msg.device = n3ds_spi->current_cs;
+
+	if (tfr->tx_buf) {
+		n3ds_msg.buffer = (void *)tfr->tx_buf;
+		nintendo3ds_spi_write_msg(n3ds_spi->base_addr,
+			&n3ds_msg);
+	} else if (tfr->rx_buf) {
+		n3ds_msg.buffer = tfr->rx_buf;
+		nintendo3ds_spi_read_msg(n3ds_spi->base_addr,
+			&n3ds_msg);
+	} else {
+		dev_err(&spi->dev, "%s: null SPI transfer", __func__);
+		return -EINVAL;
+	}
+
+	if (spi_transfer_is_last(master, tfr)) {
+		nintendo3ds_spi_msg_done(n3ds_spi->base_addr);
+	}
+
+	spi_finalize_current_transfer(master);
+
+	return 0;
+}
+
+static int nintendo3ds_spi_probe(struct platform_device *pdev)
+{
+	struct nintendo3ds_spi *n3ds_spi;
+	struct resource *mem;
+	struct spi_master *master;
+	int ret;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct nintendo3ds_spi));
+	if (IS_ERR(master)) {
+		dev_err(&pdev->dev, "failed to allocate driver");
+		return PTR_ERR(master);
+	}
+
+	platform_set_drvdata(pdev, master);
+	n3ds_spi = spi_master_get_devdata(master);
+
+	n3ds_spi->master = master;
+	master->bus_num = pdev->id;
+	master->set_cs = nintendo3ds_spi_set_cs;
+	master->transfer_one = nintendo3ds_spi_transfer_one;
+	master->num_chipselect = 6;
+	master->bits_per_word_mask = SPI_BPW_MASK(8);
+	master->flags = SPI_MASTER_HALF_DUPLEX;
+	master->dev.of_node = pdev->dev.of_node;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(mem)) {
+		dev_err(&pdev->dev, "failed to get memory resource");
+		return PTR_ERR(mem);
+	}
+
+	n3ds_spi->base_addr = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(n3ds_spi->base_addr)) {
+		dev_err(&pdev->dev, "failed to map registers");
+		return PTR_ERR(n3ds_spi->base_addr);
+	}
+
+	/* Stop any possible running transfer */
+	spi_reg_new_cnt_write(n3ds_spi->base_addr, 0);
+
+	ret = devm_spi_register_master(&pdev->dev, master);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register SPI master (%d)", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nintendo3ds_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	spi_master_put(master);
+	return 0;
+}
+
+
+MODULE_ALIAS("platform:" DRIVER_NAME);
+
+static const struct of_device_id nintendo3ds_spi_of_match[] = {
+	{ .compatible = "nintendo3ds,nintendo3ds-spi", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_spi_of_match);
+
+static struct platform_driver nintendo3ds_spi_driver = {
+	.probe	= nintendo3ds_spi_probe,
+	.remove	= nintendo3ds_spi_remove,
+
+	.driver = {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table	= of_match_ptr(nintendo3ds_spi_of_match),
+	},
+};
+module_platform_driver(nintendo3ds_spi_driver);
+
+MODULE_AUTHOR("Sergi Granell <xerpi.g.12@gmail.com>");
+MODULE_DESCRIPTION("Nintendo 3DS SPI driver");
+MODULE_LICENSE("GPL");
diff -Naur '--exclude=certs' linux-5.0.3/make_3ds.sh linux-3ds/make_3ds.sh
--- linux-5.0.3/make_3ds.sh	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/make_3ds.sh	2019-05-04 18:53:35.984195600 -0300
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+#cp arch/arm/configs/nintendo3ds_defconfig .config
+make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j8
+make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- nintendo3ds_ctr.dtb
+echo "Output file: ./arch/arm/boot/zImage"
+echo "Output DTB: ./arch/arm/boot/dts/nintendo3ds_ctr.dtb"
diff -Naur '--exclude=certs' linux-5.0.3/scripts/dtc/include-prefixes/arm/nintendo3ds_ctr.dts linux-3ds/scripts/dtc/include-prefixes/arm/nintendo3ds_ctr.dts
--- linux-5.0.3/scripts/dtc/include-prefixes/arm/nintendo3ds_ctr.dts	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/scripts/dtc/include-prefixes/arm/nintendo3ds_ctr.dts	2019-05-11 23:01:14.824711700 -0300
@@ -0,0 +1,244 @@
+/dts-v1/;
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	model = "Nintendo 3DS (CTR)";
+	compatible = "nintendo3ds,ctr";
+	#address-cells = <1>;
+	#size-cells = <1>;
+	interrupt-parent = <&gic>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		enable-method = "nintendo3ds,smp";
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,arm11mpcore";
+			reg = <0>;
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,arm11mpcore";
+			reg = <1>;
+		};
+	};
+
+	chosen {
+		/* No FB: bootargs = "earlyprintk keep_bootcon fbcon=rotate:1 init=/init"; */
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		bootargs = "nr_cpus=2 keep_bootcon fbcon=rotate:1 root=/dev/ram0 init=init console=tty0";
+
+		display: framebuffer@18000000 {
+			compatible = "simple-framebuffer";
+			reg = <0x18000000 (400*240*3)>;
+			width = <240>;
+			height = <400>;
+			stride = <(240*3)>;
+			format = "r8g8b8";
+		};
+
+		fcram: memory@20000000 {
+			device_type = "memory";
+			reg = <0x20000000 0x08000000>;
+		};
+	};
+
+	soc {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		compatible = "simple-bus";
+
+		interrupt-parent = <&gic>;
+
+		keys: input@10146000 {
+			compatible = "nintendo3ds,nintendo3ds-input";
+			reg = <0x10146000 0x1000>;
+		};
+
+		backlight: backlight@10202000 {
+			compatible = "nintendo3ds,nintendo3ds-backlight";
+			reg = <0x10202000 0x4000>;
+		};
+
+		pxi: pxi@10163000 {
+			compatible = "nintendo3ds,nintendo3ds-pxi";
+			interrupts =
+				<GIC_SPI 0x30 IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x33 IRQ_TYPE_EDGE_RISING>;
+			reg = <0x10163000 0x1000>;
+
+			mmc: mmc {
+				compatible = "nintendo3ds,nintendo3ds-mmc";
+			};
+
+			rng: rng {
+				compatible = "nintendo3ds,nintendo3ds-rng";
+			};
+		};
+
+		i2c1: i2c@10161000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-i2c";
+			reg = <0x10161000 0x1000>;
+		};
+
+		i2c2: i2c@10144000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-i2c";
+			reg = <0x10144000 0x1000>;
+
+			mcu: mcu@4a {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				compatible = "nintendo3ds,nintendo3ds-mcu";
+				reg = <0x4A>;
+
+				mcuhid {
+					interrupt-parent = <&gic>;
+
+					compatible = "nintendo3ds,nintendo3ds-mcuhid";
+					interrupts = <GIC_SPI 0x51 IRQ_TYPE_EDGE_RISING>;
+				};
+
+				charger {
+					compatible = "nintendo3ds,nintendo3ds-charger";
+				};
+
+				reset {
+					compatible = "nintendo3ds,nintendo3ds-reset";
+				};
+
+				leds {
+					compatible = "nintendo3ds,nintendo3ds-leds";
+				};
+
+				rtc {
+					compatible = "nintendo3ds,nintendo3ds-rtc";
+				};
+
+			};
+		};
+
+		i2c3: i2c@10148000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-i2c";
+			reg = <0x10148000 0x1000>;
+		};
+
+		spi0: spi@10160000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-spi";
+			reg = <0x10160000 0x1000>;
+
+			flash: nvram@1 {
+				compatible = "jedec,spi-nor";
+				reg = <1>;
+
+				spi-max-frequency = <256000>;
+			};
+		};
+
+		spi1: spi@10142000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-spi";
+			reg = <0x10142000 0x1000>;
+
+			ts: codec@3 {
+				compatible = "nintendo3ds,nintendo3ds-codec";
+				spi-max-frequency = <4000000>;
+				reg = <3>;
+
+				touchscreen-size-x = <4096>;
+				touchscreen-size-y = <4096>;
+				touchscreen-inverted-y;
+				touchscreen-swapped-x-y;
+			};
+		};
+
+		spi2: spi@10143000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-spi";
+			reg = <0x10143000 0x1000>;
+		};
+
+		refclk: refclk134mkhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <134000000>;
+			clock-output-names = "nintendo3ds:refclk144khz";
+		};
+
+		timer: twd-timer@17E00600 {
+			compatible = "arm,arm11mp-twd-timer";
+			reg = <0x17E00600 0x20>;
+			interrupts = <GIC_PPI 13 (GIC_CPU_MASK_RAW(0xF) | IRQ_TYPE_EDGE_RISING)>;
+			clocks = <&refclk>;
+		};
+
+		watchdog: twd-watchdog@17E00620 {
+			compatible = "arm,arm11mp-twd-wdt";
+			reg = <0x17E00620 0x20>;
+			interrupts = <GIC_PPI 14 (GIC_CPU_MASK_RAW(0xF) | IRQ_TYPE_EDGE_RISING)>;
+		};
+
+		gic: interrupt-controller@17E01000 {
+			compatible = "arm,arm11mp-gic";
+			#interrupt-cells = <3>;
+			#address-cells = <1>;
+			interrupt-controller;
+			reg = <0x17E01000 0x1000>,
+			      <0x17E00100 0x100>;
+		};
+
+		scu: scu@17E00000 {
+			compatible = "arm,arm11mp-scu";
+			reg = <0x17E00000 0x100>;
+		};
+	};
+
+	amba {
+		compatible = "arm,amba-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		dma@10200000 {
+			compatible = "arm,pl330", "arm,primecell";
+			reg = <0x10200000 0x1000>;
+
+			clocks = <&refclk>;
+			clock-names = "apb_pclk";
+
+			interrupts =
+				<GIC_SPI 0x39 IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x3A IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x3B IRQ_TYPE_EDGE_RISING>;
+
+			#dma-cells = <1>;
+			#dma-channels = <8>;
+			#dma-requests = <32>;
+		};
+	};
+
+};
